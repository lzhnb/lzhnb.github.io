!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self)["Gaussian Splat 3D"]=e["Gaussian Splat 3D"]||{},e.THREE)}(this,(function(e,t){"use strict";function n(e){var t=Object.create(null);return e&&Object.keys(e).forEach((function(n){if("default"!==n){var r=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,r.get?r:{enumerable:!0,get:function(){return e[n]}})}})),t.default=e,Object.freeze(t)}var r=n(t);!function(){const e=new Float32Array(1),t=new Int32Array(e.buffer)}();const s=function(){const e=new Float32Array(1),t=new Int32Array(e.buffer);return function(n){return e[0]=n,t[0]}}(),o=function(e,t){return new Promise(((n,r)=>{fetch(e).then((async e=>{const s=e.body.getReader();let o=0,i=e.headers.get("Content-Length"),a=i?parseInt(i):void 0;const c=[];for(;;)try{const{value:e,done:r}=await s.read();if(r){t&&t(100,"100%",e);const r=new Blob(c).arrayBuffer();n(r);break}let i,l;o+=e.length,void 0!==a&&(i=o/a*100,l=`${i.toFixed(2)}%`),c.push(e),t&&t(i,l,e)}catch(e){r(e);break}}))}))},i=function(e,t,n){return Math.max(Math.min(e,n),t)},a=function(){return performance.now()/1e3},c=new r.Vector3,l=new r.Vector3,h=new r.Vector4,d=new r.Vector4,p=new r.Quaternion,u=new r.Quaternion;let m,f;class y{static CenterComponentCount=3;static ScaleComponentCount=3;static RotationComponentCount=4;static ColorComponentCount=4;static CompressionLevels={0:{BytesPerCenter:12,BytesPerScale:12,BytesPerColor:4,BytesPerRotation:16,ScaleRange:1},1:{BytesPerCenter:6,BytesPerScale:6,BytesPerColor:4,BytesPerRotation:8,ScaleRange:32767}};static CovarianceSizeFloats=6;static CovarianceSizeBytes=24;static HeaderSizeBytes=1024;constructor(e){this.headerBufferData=new ArrayBuffer(y.HeaderSizeBytes),this.headerArrayUint8=new Uint8Array(this.headerBufferData),this.headerArrayUint32=new Uint32Array(this.headerBufferData),this.headerArrayFloat32=new Float32Array(this.headerBufferData),this.headerArrayUint8.set(new Uint8Array(e,0,y.HeaderSizeBytes)),this.versionMajor=this.headerArrayUint8[0],this.versionMinor=this.headerArrayUint8[1],this.headerExtraK=this.headerArrayUint8[2],this.compressionLevel=this.headerArrayUint8[3],this.splatCount=this.headerArrayUint32[1],this.bucketSize=this.headerArrayUint32[2],this.bucketCount=this.headerArrayUint32[3],this.bucketBlockSize=this.headerArrayFloat32[4],this.halfBucketBlockSize=this.bucketBlockSize/2,this.bytesPerBucket=this.headerArrayUint32[5],this.compressionScaleRange=this.headerArrayUint32[6]||y.CompressionLevels[this.compressionLevel].ScaleRange,this.compressionScaleFactor=this.halfBucketBlockSize/this.compressionScaleRange;const t=e.byteLength-y.HeaderSizeBytes;this.splatBufferData=new ArrayBuffer(t),new Uint8Array(this.splatBufferData).set(new Uint8Array(e,y.HeaderSizeBytes,t)),this.bytesPerCenter=y.CompressionLevels[this.compressionLevel].BytesPerCenter,this.bytesPerScale=y.CompressionLevels[this.compressionLevel].BytesPerScale,this.bytesPerColor=y.CompressionLevels[this.compressionLevel].BytesPerColor,this.bytesPerRotation=y.CompressionLevels[this.compressionLevel].BytesPerRotation,this.bytesPerSplat=this.bytesPerCenter+this.bytesPerScale+this.bytesPerColor+this.bytesPerRotation,m=this.fbf.bind(this),f=this.tbf.bind(this),this.linkBufferArrays()}linkBufferArrays(){let e=0===this.compressionLevel?Float32Array:Uint16Array;this.centerArray=new e(this.splatBufferData,0,this.splatCount*y.CenterComponentCount),this.scaleArray=new e(this.splatBufferData,this.bytesPerCenter*this.splatCount,this.splatCount*y.ScaleComponentCount),this.colorArray=new Uint8Array(this.splatBufferData,(this.bytesPerCenter+this.bytesPerScale)*this.splatCount,this.splatCount*y.ColorComponentCount),this.rotationArray=new e(this.splatBufferData,(this.bytesPerCenter+this.bytesPerScale+this.bytesPerColor)*this.splatCount,this.splatCount*y.RotationComponentCount),this.bucketsBase=this.splatCount*this.bytesPerSplat}fbf(e){return 0===this.compressionLevel?e:r.DataUtils.fromHalfFloat(e)}tbf(e){return 0===this.compressionLevel?e:r.DataUtils.toHalfFloat(e)}getHeaderBufferData(){return this.headerBufferData}getSplatBufferData(){return this.splatBufferData}getCenter(e,t=new r.Vector3,n){let s=[0,0,0];const o=e*y.CenterComponentCount;if(this.compressionLevel>0){const n=this.compressionScaleFactor,r=this.compressionScaleRange,i=Math.floor(e/this.bucketSize);s=new Float32Array(this.splatBufferData,this.bucketsBase+i*this.bytesPerBucket,3),t.x=(this.centerArray[o]-r)*n+s[0],t.y=(this.centerArray[o+1]-r)*n+s[1],t.z=(this.centerArray[o+2]-r)*n+s[2]}else t.x=this.centerArray[o],t.y=this.centerArray[o+1],t.z=this.centerArray[o+2];return n&&t.applyMatrix4(n),t}setCenter(e,t){let n=[0,0,0];const r=e*y.CenterComponentCount;if(this.compressionLevel>0){const s=1/this.compressionScaleFactor,o=this.compressionScaleRange,a=2*o+1,c=Math.floor(e/this.bucketSize);n=new Float32Array(this.splatBufferData,this.bucketsBase+c*this.bytesPerBucket,3),this.centerArray[r]=i(Math.round((t.x-n[0])*s)+o,0,a),this.centerArray[r+1]=i(Math.round((t.y-n[1])*s)+o,0,a),this.centerArray[r+2]=i(Math.round((t.z-n[2])*s)+o,0,a)}else this.centerArray[r]=t.x,this.centerArray[r+1]=t.y,this.centerArray[r+2]=t.z}getScaleAndRotation=function(){const e=new r.Matrix4,t=new r.Matrix4,n=new r.Matrix4,s=new r.Vector3;return function(o,i=new r.Vector3,a=new r.Quaternion,c){const l=o*y.ScaleComponentCount;i.set(m(this.scaleArray[l]),m(this.scaleArray[l+1]),m(this.scaleArray[l+2]));const h=o*y.RotationComponentCount;a.set(m(this.rotationArray[h+1]),m(this.rotationArray[h+2]),m(this.rotationArray[h+3]),m(this.rotationArray[h])),c&&(e.makeScale(i.x,i.y,i.z),t.makeRotationFromQuaternion(a),n.copy(e).multiply(t).multiply(c),n.decompose(s,a,i))}}();getColor(e,t=new r.Vector4,n){const s=e*y.ColorComponentCount;return t.set(this.colorArray[s],this.colorArray[s+1],this.colorArray[s+2],this.colorArray[s+3]),t}setColor(e,t){const n=e*y.ColorComponentCount;this.colorArray[n]=t.x,this.colorArray[n+1]=t.y,this.colorArray[n+2]=t.z,this.colorArray[n+3]=t.w}getSplatCount(){return this.splatCount}fillCovarianceArray(e,t,n){const s=this.splatCount,o=new r.Vector3,i=new r.Quaternion,a=new r.Matrix3,c=new r.Matrix3,l=new r.Matrix3,h=new r.Matrix3,d=new r.Matrix3,p=new r.Matrix3,u=new r.Matrix4;for(let r=0;r<s;r++){const s=r*y.ScaleComponentCount;o.set(m(this.scaleArray[s]),m(this.scaleArray[s+1]),m(this.scaleArray[s+2])),u.makeScale(o.x,o.y,o.z),c.setFromMatrix4(u);const f=r*y.RotationComponentCount;i.set(m(this.rotationArray[f+1]),m(this.rotationArray[f+2]),m(this.rotationArray[f+3]),m(this.rotationArray[f])),u.makeRotationFromQuaternion(i),a.setFromMatrix4(u),l.copy(a).multiply(c),h.copy(l).transpose().premultiply(l);const g=y.CovarianceSizeFloats*(r+t);n&&(d.setFromMatrix4(n),p.copy(d).transpose(),h.multiply(p),h.premultiply(d)),e[g]=h.elements[0],e[g+1]=h.elements[3],e[g+2]=h.elements[6],e[g+3]=h.elements[4],e[g+4]=h.elements[7],e[g+5]=h.elements[8]}}fillCenterArray(e,t,n){const s=this.splatCount;let o=[0,0,0];const i=new r.Vector3;for(let r=0;r<s;r++){const s=r*y.CenterComponentCount,a=(r+t)*y.CenterComponentCount;if(this.compressionLevel>0){const e=Math.floor(r/this.bucketSize);o=new Float32Array(this.splatBufferData,this.bucketsBase+e*this.bytesPerBucket,3);const t=this.compressionScaleFactor,n=this.compressionScaleRange;i.x=(this.centerArray[s]-n)*t+o[0],i.y=(this.centerArray[s+1]-n)*t+o[1],i.z=(this.centerArray[s+2]-n)*t+o[2]}else i.x=this.centerArray[s],i.y=this.centerArray[s+1],i.z=this.centerArray[s+2];n&&i.applyMatrix4(n),e[a]=i.x,e[a+1]=i.y,e[a+2]=i.z}}fillColorArray(e,t,n){const r=this.splatCount;for(let n=0;n<r;n++){const r=n*y.ColorComponentCount,s=(n+t)*y.ColorComponentCount;e[s]=this.colorArray[r],e[s+1]=this.colorArray[r+1],e[s+2]=this.colorArray[r+2],e[s+3]=this.colorArray[r+3]}}swapVertices(e,t){const n=(e,t=new r.Vector3)=>{const n=e*y.ScaleComponentCount;return t.set(m(this.scaleArray[n]),m(this.scaleArray[n+1]),m(this.scaleArray[n+2])),t},s=(e,t)=>{const n=e*y.ScaleComponentCount;this.scaleArray[n]=f(t.x),this.scaleArray[n+1]=f(t.y),this.scaleArray[n+2]=f(t.z)},o=(e,t=new r.Quaternion)=>{const n=e*y.RotationComponentCount;return t.set(m(this.rotationArray[n+1]),m(this.rotationArray[n+2]),m(this.rotationArray[n+3]),m(this.rotationArray[n])),t},i=(e,t)=>{const n=e*y.RotationComponentCount;this.rotationArray[n]=f(t.w),this.rotationArray[n+1]=f(t.x),this.rotationArray[n+2]=f(t.y),this.rotationArray[n+3]=f(t.z)};getCenter(e,c),getCenter(t,l),setCenter(t,c),setCenter(e,l),n(e,c),n(t,l),s(t,c),s(e,l),o(e,p),o(t,u),i(t,p),i(e,u),getColor(e,h),getColor(t,d),setColor(t,h),setColor(e,d)}}class g{constructor(e=0,t=1,n=256,r=5){this.compressionLevel=e,this.minimumAlpha=t,this.bucketSize=n,this.blockSize=r}static createEmptyUncompressedSplatArray(){return{splatCount:0,scale_0:[],scale_1:[],scale_2:[],rot_0:[],rot_1:[],rot_2:[],rot_3:[],x:[],y:[],z:[],f_dc_0:[],f_dc_1:[],f_dc_2:[],opacity:[],addSplat:function(e,t,n,r,s,o,i,a,c,l,h,d,p,u){this.x.push(e),this.y.push(t),this.z.push(n),this.scale_0.push(r),this.scale_1.push(s),this.scale_2.push(o),this.rot_0.push(i),this.rot_1.push(a),this.rot_2.push(c),this.rot_3.push(l),this.f_dc_0.push(h),this.f_dc_1.push(d),this.f_dc_2.push(p),this.opacity.push(u),this.splatCount++}}}uncompressedSplatArrayToSplatBuffer(e){const t=g.createEmptyUncompressedSplatArray();t.addSplat(0,0,0,0,0,0,1,0,0,0,0,0,0,0);for(let n=0;n<e.splatCount;n++){let r;r=e.opacity[n]?e.opacity[n]:255,r>=this.minimumAlpha&&t.addSplat(e.x[n],e.y[n],e.z[n],e.scale_0[n],e.scale_1[n],e.scale_2[n],e.rot_0[n],e.rot_1[n],e.rot_2[n],e.rot_3[n],e.f_dc_0[n],e.f_dc_1[n],e.f_dc_2[n],e.opacity[n])}const n=this.computeBucketsForUncompressedSplatArray(t),s=n.length*this.bucketSize,o=y.HeaderSizeBytes,a=new Uint8Array(new ArrayBuffer(o));a[3]=this.compressionLevel,new Uint32Array(a.buffer,4,1)[0]=s;let c=y.CompressionLevels[this.compressionLevel].BytesPerCenter,l=y.CompressionLevels[this.compressionLevel].BytesPerScale,h=y.CompressionLevels[this.compressionLevel].BytesPerColor,d=y.CompressionLevels[this.compressionLevel].BytesPerRotation;const p=new ArrayBuffer(c*s),u=new ArrayBuffer(l*s),m=new ArrayBuffer(h*s),f=new ArrayBuffer(d*s),C=this.blockSize/2,A=y.CompressionLevels[this.compressionLevel].ScaleRange,v=A/C,w=2*A+1,x=new r.Vector3,b=new r.Vector3;let S=0;for(let e=0;e<n.length;e++){const s=n[e];x.fromArray(s.center);for(let e=0;e<s.splats.length;e++){let n=s.splats[e],o=!1;if(0===n&&(o=!0),0===this.compressionLevel){const e=new Float32Array(p,S*c,3),s=new Float32Array(u,S*l,3),o=new Float32Array(f,S*d,4);if(void 0!==t.scale_0[n]){const e=new r.Quaternion(t.rot_1[n],t.rot_2[n],t.rot_3[n],t.rot_0[n]);e.normalize(),o.set([e.w,e.x,e.y,e.z]),s.set([t.scale_0[n],t.scale_1[n],t.scale_2[n]])}else s.set([.01,.01,.01]),o.set([1,0,0,0]);e.set([t.x[n],t.y[n],t.z[n]])}else{const e=new Uint16Array(p,S*c,3),s=new Uint16Array(u,S*l,3),o=new Uint16Array(f,S*d,4),a=r.DataUtils.toHalfFloat.bind(r.DataUtils);if(void 0!==t.scale_0[n]){const e=new r.Quaternion(t.rot_1[n],t.rot_2[n],t.rot_3[n],t.rot_0[n]);e.normalize(),o.set([a(e.w),a(e.x),a(e.y),a(e.z)]),s.set([a(t.scale_0[n]),a(t.scale_1[n]),a(t.scale_2[n])])}else s.set([a(.01),a(.01),a(.01)]),o.set([a(1),0,0,0]);b.set(t.x[n],t.y[n],t.z[n]).sub(x),b.x=Math.round(b.x*v)+A,b.x=i(b.x,0,w),b.y=Math.round(b.y*v)+A,b.y=i(b.y,0,w),b.z=Math.round(b.z*v)+A,b.z=i(b.z,0,w),e.set([b.x,b.y,b.z])}const a=new Uint8ClampedArray(m,S*h,4);o?(a[0]=255,a[1]=0,a[2]=0,a[3]=0):(void 0!==t.f_dc_0[n]?a.set([t.f_dc_0[n],t.f_dc_1[n],t.f_dc_2[n]]):a.set([255,0,0]),void 0!==t.opacity[n]?a[3]=t.opacity[n]:a[3]=255),S++}}const M=12*n.length,P=p.byteLength+u.byteLength+m.byteLength+f.byteLength,T=new Uint32Array(a.buffer),F=new Float32Array(a.buffer);let D=o+P;this.compressionLevel>0&&(D+=M,T[2]=this.bucketSize,T[3]=n.length,F[4]=this.blockSize,T[5]=12,T[6]=y.CompressionLevels[this.compressionLevel].ScaleRange);const B=new ArrayBuffer(D);if(new Uint8Array(B,0,o).set(a),new Uint8Array(B,o,p.byteLength).set(new Uint8Array(p)),new Uint8Array(B,o+p.byteLength,u.byteLength).set(new Uint8Array(u)),new Uint8Array(B,o+p.byteLength+u.byteLength,m.byteLength).set(new Uint8Array(m)),new Uint8Array(B,o+p.byteLength+u.byteLength+m.byteLength,f.byteLength).set(new Uint8Array(f)),this.compressionLevel>0){const e=new Float32Array(B,o+P,3*n.length);for(let t=0;t<n.length;t++){const r=n[t],s=3*t;e[s]=r.center[0],e[s+1]=r.center[1],e[s+2]=r.center[2]}}return new y(B)}computeBucketsForUncompressedSplatArray(e){let t=e.splatCount;const n=this.blockSize,s=n/2,o=new r.Vector3,i=new r.Vector3;for(let n=1;n<t;n++){const t=[e.x[n],e.y[n],e.z[n]];(0===n||t[0]<o.x)&&(o.x=t[0]),(0===n||t[0]>i.x)&&(i.x=t[0]),(0===n||t[1]<o.y)&&(o.y=t[1]),(0===n||t[1]>i.y)&&(i.y=t[1]),(0===n||t[2]<o.z)&&(o.z=t[2]),(0===n||t[2]>i.z)&&(i.z=t[2])}const a=(new r.Vector3).copy(i).sub(o),c=Math.ceil(a.y/n),l=Math.ceil(a.z/n),h=new r.Vector3,d=[],p={};for(let r=1;r<t;r++){const t=[e.x[r],e.y[r],e.z[r]],i=Math.ceil((t[0]-o.x)/n),a=Math.ceil((t[1]-o.y)/n),u=Math.ceil((t[2]-o.z)/n);h.x=(i-1)*n+o.x+s,h.y=(a-1)*n+o.y+s,h.z=(u-1)*n+o.z+s;const m=i*(c*l)+a*l+u;let f=p[m];f||(p[m]=f={splats:[],center:h.toArray()}),f.splats.push(r),f.splats.length>=this.bucketSize&&(d.push(f),p[m]=null)}for(let e in p)if(p.hasOwnProperty(e)){const t=p[e];if(t){for(;t.splats.length<this.bucketSize;)t.splats.push(0);d.push(t)}}return d}}class C{constructor(e){this.plyBuffer=e}decodeHeader(e){const t=new TextDecoder;let n=0,r="";console.log(".PLY size: "+e.byteLength+" bytes");const s=100;for(;;){if(n+s>=e.byteLength)throw new Error("End of file reached while searching for end of header");const o=new Uint8Array(e,n,s);r+=t.decode(o),n+=s;const i=new Uint8Array(e,Math.max(0,n-200),200);if(t.decode(i).includes("end_header"))break}const o=r.split("\n");let i=0,a={};for(let e=0;e<o.length;e++){const t=o[e].trim();if(t.startsWith("element vertex")){const e=t.match(/\d+/);e&&(i=parseInt(e[0]))}else if(t.startsWith("property")){const e=t.match(/(\w+)\s+(\w+)\s+(\w+)/);if(e){const t=e[2];a[e[3]]=t}}else if("end_header"===t)break}const c=r.indexOf("end_header")+10+1;return{splatCount:i,propertyTypes:a,vertexData:new DataView(e,c),headerOffset:n}}readRawVertexFast(e,t,n,r,s,o){let i=o||{};for(let o of r){const r=s[o];"float"===r?i[o]=e.getFloat32(t+n[o],!0):"uchar"===r&&(i[o]=e.getUint8(t+n[o])/255)}}parseToSplatBuffer(e=0,t=1){const n=performance.now();console.log("Parsing PLY to SPLAT...");const{splatCount:r,propertyTypes:s,vertexData:o}=this.decodeHeader(this.plyBuffer);let i=0;for(const e in s)e.startsWith("f_rest_")&&(i+=1);const a=i/3;console.log("Detected degree",0,"with ",a,"coefficients per color");const c=[];for(let e=0;e<3;++e)c.push(`f_dc_${e}`);for(let e=0;e<a;++e)for(let t=0;t<3;++t)c.push(`f_rest_${t*a+e}`);let l=0,h={};const d={double:8,int:4,uint:4,float:4,short:2,ushort:2,uchar:1};for(let e in s)if(s.hasOwnProperty(e)){const t=s[e];h[e]=l,l+=d[t]}let p={};const u=["scale_0","scale_1","scale_2","rot_0","rot_1","rot_2","rot_3","x","y","z","f_dc_0","f_dc_1","f_dc_2","opacity"],m=g.createEmptyUncompressedSplatArray();for(let e=0;e<r;e++){if(this.readRawVertexFast(o,e*l,h,u,s,p),void 0!==p.scale_0?(m.scale_0[e]=Math.exp(p.scale_0),m.scale_1[e]=Math.exp(p.scale_1),m.scale_2[e]=Math.exp(p.scale_2)):(m.scale_0[e]=.01,m.scale_1[e]=.01,m.scale_2[e]=.01),void 0!==p.f_dc_0){const t=.28209479177387814;m.f_dc_0[e]=255*(.5+t*p.f_dc_0),m.f_dc_1[e]=255*(.5+t*p.f_dc_1),m.f_dc_2[e]=255*(.5+t*p.f_dc_2)}else m.f_dc_0[e]=0,m.f_dc_1[e]=0,m.f_dc_2[e]=0;void 0!==p.opacity&&(m.opacity[e]=1/(1+Math.exp(-p.opacity))*255),m.rot_0[e]=p.rot_0,m.rot_1[e]=p.rot_1,m.rot_2[e]=p.rot_2,m.rot_3[e]=p.rot_3,m.x[e]=p.x,m.y[e]=p.y,m.z[e]=p.z,m.splatCount++}const f=new g(e,t).uncompressedSplatArrayToSplatBuffer(m);console.log("Total valid splats: ",f.getSplatCount(),"out of",r);const y=performance.now();return console.log("Parsing PLY to SPLAT complete!"),console.log("Total time: ",(y-n).toFixed(2)+" ms"),f}}class A{constructor(){this.splatBuffer=null}fetchFile(e,t){return new Promise(((n,r)=>{o(e,t).then((e=>{n(e)})).catch((e=>{r(e)}))}))}loadFromURL(e,t,n=0,r=1){return new Promise(((s,o)=>{this.fetchFile(e,t).then((e=>{const t=new C(e).parseToSplatBuffer(n,r);this.splatBuffer=t,s(t)})).catch((e=>{o(e)}))}))}}class v{constructor(e=null){this.splatBuffer=e,this.downLoadLink=null}static isFileSplatFormat(e){return v.isCustomSplatFormat(e)||v.isStandardSplatFormat(e)}static isCustomSplatFormat(e){return e.endsWith(".ksplat")}static isStandardSplatFormat(e){return e.endsWith(".splat")}loadFromURL(e,t){return new Promise(((n,r)=>{o(e,t).then((t=>{let r;if(v.isCustomSplatFormat(e))r=new y(t);else{const e=new g(0,1),n=v.parseStandardSplatToUncompressedSplatArray(t);r=e.uncompressedSplatArrayToSplatBuffer(n)}n(r)})).catch((e=>{r(e)}))}))}static parseStandardSplatToUncompressedSplatArray(e){const t=e.byteLength/32,n=g.createEmptyUncompressedSplatArray();for(let s=0;s<t;s++){const t=12,o=12,i=4,a=32*s,c=new Float32Array(e,a,3),l=new Float32Array(e,a+t,3),h=new Uint8Array(e,a+t+o,4),d=new Uint8Array(e,a+t+o+i,4),p=new r.Quaternion((d[1]-128)/128,(d[2]-128)/128,(d[3]-128)/128,(d[0]-128)/128);p.normalize(),n.addSplat(c[0],c[1],c[2],l[0],l[1],l[2],p.w,p.x,p.y,p.z,h[0],h[1],h[2],h[3])}return n}setFromBuffer(e){this.splatBuffer=e}downloadFile(e){const t=new Uint8Array(this.splatBuffer.getHeaderBufferData()),n=new Uint8Array(this.splatBuffer.getSplatBufferData()),r=new Blob([t.buffer,n.buffer],{type:"application/octet-stream"});this.downLoadLink||(this.downLoadLink=document.createElement("a"),document.body.appendChild(this.downLoadLink)),this.downLoadLink.download=e,this.downLoadLink.href=URL.createObjectURL(r),this.downLoadLink.click()}}const w={type:"change"},x={type:"start"},b={type:"end"},S=new t.Ray,M=new t.Plane,P=Math.cos(70*t.MathUtils.DEG2RAD);class T extends t.EventDispatcher{constructor(e,n){super(),this.object=e,this.domElement=n,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new t.Vector3,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.zoomToCursor=!1,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"KeyA",UP:"KeyW",RIGHT:"KeyD",BOTTOM:"KeyS"},this.mouseButtons={LEFT:t.MOUSE.ROTATE,MIDDLE:t.MOUSE.DOLLY,RIGHT:t.MOUSE.PAN},this.touches={ONE:t.TOUCH.ROTATE,TWO:t.TOUCH.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return a.phi},this.getAzimuthalAngle=function(){return a.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(e){e.addEventListener("keydown",J),this._domElementKeyEvents=e},this.stopListenToKeyEvents=function(){this._domElementKeyEvents.removeEventListener("keydown",J),this._domElementKeyEvents=null},this.saveState=function(){r.target0.copy(r.target),r.position0.copy(r.object.position),r.zoom0=r.object.zoom},this.reset=function(){r.target.copy(r.target0),r.object.position.copy(r.position0),r.object.zoom=r.zoom0,r.object.updateProjectionMatrix(),r.dispatchEvent(w),r.update(),o=s.NONE},this.update=function(){const n=new t.Vector3,d=(new t.Quaternion).setFromUnitVectors(e.up,new t.Vector3(0,1,0)),p=d.clone().invert(),u=new t.Vector3,m=new t.Quaternion,f=new t.Vector3,y=2*Math.PI;return function(){d.setFromUnitVectors(e.up,new t.Vector3(0,1,0)),p.copy(d).invert();const g=r.object.position;n.copy(g).sub(r.target),n.applyQuaternion(d),a.setFromVector3(n),r.autoRotate&&o===s.NONE&&E(2*Math.PI/60/60*r.autoRotateSpeed),r.enableDamping?(a.theta+=c.theta*r.dampingFactor,a.phi+=c.phi*r.dampingFactor):(a.theta+=c.theta,a.phi+=c.phi);let C=r.minAzimuthAngle,A=r.maxAzimuthAngle;isFinite(C)&&isFinite(A)&&(C<-Math.PI?C+=y:C>Math.PI&&(C-=y),A<-Math.PI?A+=y:A>Math.PI&&(A-=y),a.theta=C<=A?Math.max(C,Math.min(A,a.theta)):a.theta>(C+A)/2?Math.max(C,a.theta):Math.min(A,a.theta)),a.phi=Math.max(r.minPolarAngle,Math.min(r.maxPolarAngle,a.phi)),a.makeSafe(),!0===r.enableDamping?r.target.addScaledVector(h,r.dampingFactor):r.target.add(h),r.zoomToCursor&&F||r.object.isOrthographicCamera?a.radius=O(a.radius):a.radius=O(a.radius*l),n.setFromSpherical(a),n.applyQuaternion(p),g.copy(r.target).add(n),r.object.lookAt(r.target),!0===r.enableDamping?(c.theta*=1-r.dampingFactor,c.phi*=1-r.dampingFactor,h.multiplyScalar(1-r.dampingFactor)):(c.set(0,0,0),h.set(0,0,0));let x=!1;if(r.zoomToCursor&&F){let s=null;if(r.object.isPerspectiveCamera){const e=n.length();s=O(e*l);const t=e-s;r.object.position.addScaledVector(v,t),r.object.updateMatrixWorld()}else if(r.object.isOrthographicCamera){const e=new t.Vector3(T.x,T.y,0);e.unproject(r.object),r.object.zoom=Math.max(r.minZoom,Math.min(r.maxZoom,r.object.zoom/l)),r.object.updateProjectionMatrix(),x=!0;const o=new t.Vector3(T.x,T.y,0);o.unproject(r.object),r.object.position.sub(o).add(e),r.object.updateMatrixWorld(),s=n.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),r.zoomToCursor=!1;null!==s&&(this.screenSpacePanning?r.target.set(0,0,-1).transformDirection(r.object.matrix).multiplyScalar(s).add(r.object.position):(S.origin.copy(r.object.position),S.direction.set(0,0,-1).transformDirection(r.object.matrix),Math.abs(r.object.up.dot(S.direction))<P?e.lookAt(r.target):(M.setFromNormalAndCoplanarPoint(r.object.up,r.target),S.intersectPlane(M,r.target))))}else r.object.isOrthographicCamera&&(r.object.zoom=Math.max(r.minZoom,Math.min(r.maxZoom,r.object.zoom/l)),r.object.updateProjectionMatrix(),x=!0);return l=1,F=!1,!!(x||u.distanceToSquared(r.object.position)>i||8*(1-m.dot(r.object.quaternion))>i||f.distanceToSquared(r.target)>0)&&(r.dispatchEvent(w),u.copy(r.object.position),m.copy(r.object.quaternion),f.copy(r.target),x=!1,!0)}}(),this.dispose=function(){r.domElement.removeEventListener("contextmenu",ee),r.domElement.removeEventListener("pointerdown",X),r.domElement.removeEventListener("pointercancel",q),r.domElement.removeEventListener("wheel",Z),r.domElement.removeEventListener("pointermove",$),r.domElement.removeEventListener("pointerup",q),null!==r._domElementKeyEvents&&(r._domElementKeyEvents.removeEventListener("keydown",J),r._domElementKeyEvents=null)};const r=this,s={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let o=s.NONE;const i=1e-6,a=new t.Spherical,c=new t.Spherical;let l=1;const h=new t.Vector3,d=new t.Vector2,p=new t.Vector2,u=new t.Vector2,m=new t.Vector2,f=new t.Vector2,y=new t.Vector2,g=new t.Vector2,C=new t.Vector2,A=new t.Vector2,v=new t.Vector3,T=new t.Vector2;let F=!1;const D=[],B={};function R(){return Math.pow(.95,r.zoomSpeed)}function E(e){c.theta-=e}function k(e){c.phi-=e}const I=function(){const e=new t.Vector3;return function(t,n){e.setFromMatrixColumn(n,0),e.multiplyScalar(-t),h.add(e)}}(),_=function(){const e=new t.Vector3;return function(t,n){!0===r.screenSpacePanning?e.setFromMatrixColumn(n,1):(e.setFromMatrixColumn(n,0),e.crossVectors(r.object.up,e)),e.multiplyScalar(t),h.add(e)}}(),V=function(){const e=new t.Vector3;return function(t,n){const s=r.domElement;if(r.object.isPerspectiveCamera){const o=r.object.position;e.copy(o).sub(r.target);let i=e.length();i*=Math.tan(r.object.fov/2*Math.PI/180),I(2*t*i/s.clientHeight,r.object.matrix),_(2*n*i/s.clientHeight,r.object.matrix)}else r.object.isOrthographicCamera?(I(t*(r.object.right-r.object.left)/r.object.zoom/s.clientWidth,r.object.matrix),_(n*(r.object.top-r.object.bottom)/r.object.zoom/s.clientHeight,r.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),r.enablePan=!1)}}();function z(e){r.object.isPerspectiveCamera||r.object.isOrthographicCamera?l/=e:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),r.enableZoom=!1)}function U(e){r.object.isPerspectiveCamera||r.object.isOrthographicCamera?l*=e:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),r.enableZoom=!1)}function L(t){if(!r.zoomToCursor)return;F=!0;const n=r.domElement.getBoundingClientRect(),s=t.clientX-n.left,o=t.clientY-n.top,i=n.width,a=n.height;T.x=s/i*2-1,T.y=-o/a*2+1,v.set(T.x,T.y,1).unproject(e).sub(e.position).normalize()}function O(e){return Math.max(r.minDistance,Math.min(r.maxDistance,e))}function N(e){d.set(e.clientX,e.clientY)}function j(e){m.set(e.clientX,e.clientY)}function H(){if(1===D.length)d.set(D[0].pageX,D[0].pageY);else{const e=.5*(D[0].pageX+D[1].pageX),t=.5*(D[0].pageY+D[1].pageY);d.set(e,t)}}function W(){if(1===D.length)m.set(D[0].pageX,D[0].pageY);else{const e=.5*(D[0].pageX+D[1].pageX),t=.5*(D[0].pageY+D[1].pageY);m.set(e,t)}}function G(){const e=D[0].pageX-D[1].pageX,t=D[0].pageY-D[1].pageY,n=Math.sqrt(e*e+t*t);g.set(0,n)}function Y(e){if(1==D.length)p.set(e.pageX,e.pageY);else{const t=ne(e),n=.5*(e.pageX+t.x),r=.5*(e.pageY+t.y);p.set(n,r)}u.subVectors(p,d).multiplyScalar(r.rotateSpeed);const t=r.domElement;E(2*Math.PI*u.x/t.clientHeight),k(2*Math.PI*u.y/t.clientHeight),d.copy(p)}function Q(e){if(1===D.length)f.set(e.pageX,e.pageY);else{const t=ne(e),n=.5*(e.pageX+t.x),r=.5*(e.pageY+t.y);f.set(n,r)}y.subVectors(f,m).multiplyScalar(r.panSpeed),V(y.x,y.y),m.copy(f)}function K(e){const t=ne(e),n=e.pageX-t.x,s=e.pageY-t.y,o=Math.sqrt(n*n+s*s);C.set(0,o),A.set(0,Math.pow(C.y/g.y,r.zoomSpeed)),z(A.y),g.copy(C)}function X(e){!1!==r.enabled&&(0===D.length&&(r.domElement.setPointerCapture(e.pointerId),r.domElement.addEventListener("pointermove",$),r.domElement.addEventListener("pointerup",q)),function(e){D.push(e)}(e),"touch"===e.pointerType?function(e){switch(te(e),D.length){case 1:switch(r.touches.ONE){case t.TOUCH.ROTATE:if(!1===r.enableRotate)return;H(),o=s.TOUCH_ROTATE;break;case t.TOUCH.PAN:if(!1===r.enablePan)return;W(),o=s.TOUCH_PAN;break;default:o=s.NONE}break;case 2:switch(r.touches.TWO){case t.TOUCH.DOLLY_PAN:if(!1===r.enableZoom&&!1===r.enablePan)return;r.enableZoom&&G(),r.enablePan&&W(),o=s.TOUCH_DOLLY_PAN;break;case t.TOUCH.DOLLY_ROTATE:if(!1===r.enableZoom&&!1===r.enableRotate)return;r.enableZoom&&G(),r.enableRotate&&H(),o=s.TOUCH_DOLLY_ROTATE;break;default:o=s.NONE}break;default:o=s.NONE}o!==s.NONE&&r.dispatchEvent(x)}(e):function(e){let n;switch(e.button){case 0:n=r.mouseButtons.LEFT;break;case 1:n=r.mouseButtons.MIDDLE;break;case 2:n=r.mouseButtons.RIGHT;break;default:n=-1}switch(n){case t.MOUSE.DOLLY:if(!1===r.enableZoom)return;!function(e){L(e),g.set(e.clientX,e.clientY)}(e),o=s.DOLLY;break;case t.MOUSE.ROTATE:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===r.enablePan)return;j(e),o=s.PAN}else{if(!1===r.enableRotate)return;N(e),o=s.ROTATE}break;case t.MOUSE.PAN:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===r.enableRotate)return;N(e),o=s.ROTATE}else{if(!1===r.enablePan)return;j(e),o=s.PAN}break;default:o=s.NONE}o!==s.NONE&&r.dispatchEvent(x)}(e))}function $(e){!1!==r.enabled&&("touch"===e.pointerType?function(e){switch(te(e),o){case s.TOUCH_ROTATE:if(!1===r.enableRotate)return;Y(e),r.update();break;case s.TOUCH_PAN:if(!1===r.enablePan)return;Q(e),r.update();break;case s.TOUCH_DOLLY_PAN:if(!1===r.enableZoom&&!1===r.enablePan)return;!function(e){r.enableZoom&&K(e),r.enablePan&&Q(e)}(e),r.update();break;case s.TOUCH_DOLLY_ROTATE:if(!1===r.enableZoom&&!1===r.enableRotate)return;!function(e){r.enableZoom&&K(e),r.enableRotate&&Y(e)}(e),r.update();break;default:o=s.NONE}}(e):function(e){switch(o){case s.ROTATE:if(!1===r.enableRotate)return;!function(e){p.set(e.clientX,e.clientY),u.subVectors(p,d).multiplyScalar(r.rotateSpeed);const t=r.domElement;E(2*Math.PI*u.x/t.clientHeight),k(2*Math.PI*u.y/t.clientHeight),d.copy(p),r.update()}(e);break;case s.DOLLY:if(!1===r.enableZoom)return;!function(e){C.set(e.clientX,e.clientY),A.subVectors(C,g),A.y>0?z(R()):A.y<0&&U(R()),g.copy(C),r.update()}(e);break;case s.PAN:if(!1===r.enablePan)return;!function(e){f.set(e.clientX,e.clientY),y.subVectors(f,m).multiplyScalar(r.panSpeed),V(y.x,y.y),m.copy(f),r.update()}(e)}}(e))}function q(e){!function(e){delete B[e.pointerId];for(let t=0;t<D.length;t++)if(D[t].pointerId==e.pointerId)return void D.splice(t,1)}(e),0===D.length&&(r.domElement.releasePointerCapture(e.pointerId),r.domElement.removeEventListener("pointermove",$),r.domElement.removeEventListener("pointerup",q)),r.dispatchEvent(b),o=s.NONE}function Z(e){!1!==r.enabled&&!1!==r.enableZoom&&o===s.NONE&&(e.preventDefault(),r.dispatchEvent(x),function(e){L(e),e.deltaY<0?U(R()):e.deltaY>0&&z(R()),r.update()}(e),r.dispatchEvent(b))}function J(e){!1!==r.enabled&&!1!==r.enablePan&&function(e){let t=!1;switch(e.code){case r.keys.UP:e.ctrlKey||e.metaKey||e.shiftKey?k(2*Math.PI*r.rotateSpeed/r.domElement.clientHeight):V(0,r.keyPanSpeed),t=!0;break;case r.keys.BOTTOM:e.ctrlKey||e.metaKey||e.shiftKey?k(-2*Math.PI*r.rotateSpeed/r.domElement.clientHeight):V(0,-r.keyPanSpeed),t=!0;break;case r.keys.LEFT:e.ctrlKey||e.metaKey||e.shiftKey?E(2*Math.PI*r.rotateSpeed/r.domElement.clientHeight):V(r.keyPanSpeed,0),t=!0;break;case r.keys.RIGHT:e.ctrlKey||e.metaKey||e.shiftKey?E(-2*Math.PI*r.rotateSpeed/r.domElement.clientHeight):V(-r.keyPanSpeed,0),t=!0}t&&(e.preventDefault(),r.update())}(e)}function ee(e){!1!==r.enabled&&e.preventDefault()}function te(e){let n=B[e.pointerId];void 0===n&&(n=new t.Vector2,B[e.pointerId]=n),n.set(e.pageX,e.pageY)}function ne(e){const t=e.pointerId===D[0].pointerId?D[1]:D[0];return B[t.pointerId]}r.domElement.addEventListener("contextmenu",ee),r.domElement.addEventListener("pointerdown",X),r.domElement.addEventListener("pointercancel",q),r.domElement.addEventListener("wheel",Z,{passive:!1}),this.update()}}class F{constructor(e,t){this.message=e||"Loading...",this.container=t||document.body,this.spinnerDivContainerOuter=document.createElement("div"),this.spinnerDivContainerOuter.className="outerContainer",this.spinnerDivContainerOuter.style.display="none",this.spinnerDivContainer=document.createElement("div"),this.spinnerDivContainer.className="container",this.spinnerDiv=document.createElement("div"),this.spinnerDiv.className="loader",this.messageDiv=document.createElement("div"),this.messageDiv.className="message",this.messageDiv.innerHTML=this.message,this.spinnerDivContainer.appendChild(this.spinnerDiv),this.spinnerDivContainer.appendChild(this.messageDiv),this.spinnerDivContainerOuter.appendChild(this.spinnerDivContainer),this.container.appendChild(this.spinnerDivContainerOuter);const n=document.createElement("style");n.innerHTML="\n\n            .message {\n                font-family: arial;\n                font-size: 12pt;\n                color: #ffffff;\n                text-align: center;\n                padding-top:15px;\n                width: 180px;\n            }\n\n            .outerContainer {\n                width: 100%;\n                height: 100%;\n            }\n\n            .container {\n                position: absolute;\n                top: 50%;\n                left: 50%;\n                transform: translate(-80px, -80px);\n                width: 180px;\n            }\n\n            .loader {\n                width: 120px;        /* the size */\n                padding: 15px;       /* the border thickness */\n                background: #07e8d6; /* the color */\n                z-index:99999;\n            \n                aspect-ratio: 1;\n                border-radius: 50%;\n                --_m: \n                    conic-gradient(#0000,#000),\n                    linear-gradient(#000 0 0) content-box;\n                -webkit-mask: var(--_m);\n                    mask: var(--_m);\n                -webkit-mask-composite: source-out;\n                    mask-composite: subtract;\n                box-sizing: border-box;\n                animation: load 1s linear infinite;\n                margin-left: 30px;\n            }\n            \n            @keyframes load {\n                to{transform: rotate(1turn)}\n            }\n\n        ",this.spinnerDivContainerOuter.appendChild(n)}show(){this.spinnerDivContainerOuter.style.display="block"}hide(){this.spinnerDivContainerOuter.style.display="none"}setContainer(e){this.container&&this.container.removeChild(this.spinnerDivContainerOuter),this.container=e,this.container.appendChild(this.spinnerDivContainerOuter),this.spinnerDivContainerOuter.style.zIndex=this.container.style.zIndex+1}setMessage(e){this.messageDiv.innerHTML=e}}class D extends r.Object3D{constructor(e=new r.Vector3(0,0,1),t=new r.Vector3(0,0,0),n=1,s=.1,o=16776960,i=.2*n,a=.2*i){super(),this.type="ArrowHelper";const c=new r.CylinderGeometry(s,s,n,32);c.translate(0,n/2,0);const l=new r.CylinderGeometry(0,a,i,32);l.translate(0,n,0),this.position.copy(t),this.line=new r.Mesh(c,new r.MeshBasicMaterial({color:o,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new r.Mesh(l,new r.MeshBasicMaterial({color:o,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{_axis.set(e.z,0,-e.x).normalize();const t=Math.acos(e.y);this.quaternion.setFromAxisAngle(_axis,t)}}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class B{constructor(e){this.scene=e,this.splatRenderTarget=null,this.renderTargetCopyMaterial=null,this.renderTargetCopyQuad=null,this.renderTargetCopyCamera=null,this.meshCursor=null,this.focusMarker=null,this.controlPlane=null}updateSplatRenderTargetForRenderDimensions(e,t){this.splatRenderTarget=new r.WebGLRenderTarget(e,t,{format:r.RGBAFormat,stencilBuffer:!1,depthBuffer:!0}),this.splatRenderTarget.depthTexture=new r.DepthTexture(e,t),this.splatRenderTarget.depthTexture.format=r.DepthFormat,this.splatRenderTarget.depthTexture.type=r.UnsignedIntType}setupRenderTargetCopyObjects(){this.renderTargetCopyMaterial=new r.ShaderMaterial({vertexShader:"\n                varying vec2 vUv;\n                void main() {\n                    vUv = uv;\n                    gl_Position = vec4( position.xy, 0.0, 1.0 );    \n                }\n            ",fragmentShader:"\n                #include <common>\n                #include <packing>\n                varying vec2 vUv;\n                uniform sampler2D sourceColorTexture;\n                uniform sampler2D sourceDepthTexture;\n                void main() {\n                    vec4 color = texture2D(sourceColorTexture, vUv);\n                    float fragDepth = texture2D(sourceDepthTexture, vUv).x;\n                    gl_FragDepth = fragDepth;\n                    gl_FragColor = vec4(color.rgb, color.a * 2.0);\n              }\n            ",uniforms:{sourceColorTexture:{type:"t",value:null},sourceDepthTexture:{type:"t",value:null}},depthWrite:!1,depthTest:!1,transparent:!0,blending:r.CustomBlending,blendSrc:r.SrcAlphaFactor,blendSrcAlpha:r.SrcAlphaFactor,blendDst:r.OneMinusSrcAlphaFactor,blendDstAlpha:r.OneMinusSrcAlphaFactor}),this.renderTargetCopyMaterial.extensions.fragDepth=!0,this.renderTargetCopyQuad=new r.Mesh(new r.PlaneGeometry(2,2),this.renderTargetCopyMaterial),this.renderTargetCopyCamera=new r.OrthographicCamera(-1,1,1,-1,0,1)}setupMeshCursor(){if(!this.meshCursor){const e=new r.ConeGeometry(.5,1.5,32),t=new r.MeshBasicMaterial({color:16777215}),n=new r.Mesh(e,t);n.rotation.set(0,0,Math.PI),n.position.set(0,1,0);const s=new r.Mesh(e,t);s.position.set(0,-1,0);const o=new r.Mesh(e,t);o.rotation.set(0,0,Math.PI/2),o.position.set(1,0,0);const i=new r.Mesh(e,t);i.rotation.set(0,0,-Math.PI/2),i.position.set(-1,0,0),this.meshCursor=new r.Object3D,this.meshCursor.add(n),this.meshCursor.add(s),this.meshCursor.add(o),this.meshCursor.add(i),this.meshCursor.scale.set(.1,.1,.1),this.scene.add(this.meshCursor),this.meshCursor.visible=!1}}destroyMeshCursor(){this.meshCursor&&(this.meshCursor.children.forEach((e=>{e.geometry.dispose(),e.material.dispose()})),this.scene.remove(this.meshCursor),this.meshCursor=null)}setMeshCursorVisibility(e){this.meshCursor.visible=e}setMeshCursorPosition(e){this.meshCursor.position.copy(e)}positionAndOrientMeshCursor(e,t){this.meshCursor.position.copy(e),this.meshCursor.up.copy(t.up),this.meshCursor.lookAt(t.position)}setupFocusMarker(){if(!this.focusMarker){const e=new r.SphereGeometry(.5,32,32),t=B.buildFocusMarkerMaterial();t.depthTest=!1,t.depthWrite=!1,t.transparent=!0;const n=new r.Mesh(e,t);this.focusMarker=n}}updateFocusMarker=function(){const e=new r.Vector3,t=new r.Matrix4;return function(n,r,s){t.copy(r.matrixWorld).invert(),e.copy(n).applyMatrix4(t),e.normalize().multiplyScalar(10),e.applyMatrix4(r.matrixWorld),this.focusMarker.position.copy(e),this.focusMarker.material.uniforms.realFocusPosition.value.copy(n),this.focusMarker.material.uniforms.viewport.value.copy(s),this.focusMarker.material.uniformsNeedUpdate=!0}}();setFocusMarkerVisibility(e){this.focusMarker.visible=e}setFocusMarkerOpacity(e){this.focusMarker.material.uniforms.opacity.value=e,this.focusMarker.material.uniformsNeedUpdate=!0}getFocusMarkerOpacity(){return this.focusMarker.material.uniforms.opacity.value}setupControlPlane(){const e=new r.PlaneGeometry(1,1);e.rotateX(-Math.PI/2);const t=new r.MeshBasicMaterial({color:16777215});t.transparent=!0,t.opacity=.6,t.depthTest=!1,t.depthWrite=!1,t.side=r.DoubleSide;const n=new r.Mesh(e,t),s=new r.Vector3(0,1,0);s.normalize();const o=new r.Vector3(0,0,0),i=new D(s,o,.5,.01,56576,.1,.03);this.controlPlane=new r.Object3D,this.controlPlane.add(n),this.controlPlane.add(i)}setControlPlaneVisibility(e){this.controlPlane.visible=e}positionAndOrientControlPlane=function(){const e=new r.Quaternion,t=new r.Vector3(0,1,0);return function(n,r){e.setFromUnitVectors(t,r),this.controlPlane.position.copy(n),this.controlPlane.quaternion.copy(e)}}();addDebugMeshes(){this.debugRoot=this.createDebugMeshes(),this.secondaryDebugRoot=this.createSecondaryDebugMeshes(),this.scene.add(this.debugRoot),this.scene.add(this.secondaryDebugRoot)}createDebugMeshes(e){const t=new r.SphereGeometry(1,32,32),n=new r.Object3D,s=(s,o)=>{let i=new r.Mesh(t,B.buildDebugMaterial(s));i.renderOrder=e,n.add(i),i.position.fromArray(o)};return s(16711680,[-50,0,0]),s(16711680,[50,0,0]),s(65280,[0,0,-50]),s(65280,[0,0,50]),s(16755200,[5,0,5]),n}createSecondaryDebugMeshes(e){const t=new r.BoxGeometry(3,3,3),n=new r.Object3D;const s=s=>{let o=new r.Mesh(t,B.buildDebugMaterial(12303291));o.renderOrder=e,n.add(o),o.position.fromArray(s)};let o=10;return s([-10,0,-10]),s([-10,0,o]),s([o,0,-10]),s([o,0,o]),n}static buildDebugMaterial(e){const t={color:{type:"v3",value:new r.Color(e)}},n=new r.ShaderMaterial({uniforms:t,vertexShader:"\n            #include <common>\n            varying float ndcDepth;\n\n            void main() {\n                gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position.xyz, 1.0);\n                ndcDepth = gl_Position.z / gl_Position.w;\n                gl_Position.x = gl_Position.x / gl_Position.w;\n                gl_Position.y = gl_Position.y / gl_Position.w;\n                gl_Position.z = 0.0;\n                gl_Position.w = 1.0;\n    \n            }\n        ",fragmentShader:"\n            #include <common>\n            uniform vec3 color;\n            varying float ndcDepth;\n            void main() {\n                gl_FragDepth = (ndcDepth + 1.0) / 2.0;\n                gl_FragColor = vec4(color.rgb, 0.0);\n            }\n        ",transparent:!1,depthTest:!0,depthWrite:!0,side:r.FrontSide});return n.extensions.fragDepth=!0,n}static buildFocusMarkerMaterial(e){const t={color:{type:"v3",value:new r.Color(e)},realFocusPosition:{type:"v3",value:new r.Vector3},viewport:{type:"v2",value:new r.Vector2},opacity:{value:0}};return new r.ShaderMaterial({uniforms:t,vertexShader:"\n            #include <common>\n\n            uniform vec2 viewport;\n            uniform vec3 realFocusPosition;\n\n            varying vec4 ndcPosition;\n            varying vec4 ndcCenter;\n            varying vec4 ndcFocusPosition;\n\n            void main() {\n                float radius = 0.01;\n\n                vec4 viewPosition = modelViewMatrix * vec4(position.xyz, 1.0);\n                vec4 viewCenter = modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n\n                vec4 viewFocusPosition = modelViewMatrix * vec4(realFocusPosition, 1.0);\n\n                ndcPosition = projectionMatrix * viewPosition;\n                ndcPosition = ndcPosition * vec4(1.0 / ndcPosition.w);\n                ndcCenter = projectionMatrix * viewCenter;\n                ndcCenter = ndcCenter * vec4(1.0 / ndcCenter.w);\n\n                ndcFocusPosition = projectionMatrix * viewFocusPosition;\n                ndcFocusPosition = ndcFocusPosition * vec4(1.0 / ndcFocusPosition.w);\n\n                gl_Position = projectionMatrix * viewPosition;\n\n            }\n        ",fragmentShader:"\n            #include <common>\n            uniform vec3 color;\n            uniform vec2 viewport;\n            uniform float opacity;\n\n            varying vec4 ndcPosition;\n            varying vec4 ndcCenter;\n            varying vec4 ndcFocusPosition;\n\n            void main() {\n                vec2 screenPosition = vec2(ndcPosition) * viewport;\n                vec2 screenCenter = vec2(ndcCenter) * viewport;\n\n                vec2 screenVec = screenPosition - screenCenter;\n\n                float projectedRadius = length(screenVec);\n\n                float lineWidth = 0.0005 * viewport.y;\n                float aaRange = 0.0025 * viewport.y;\n                float radius = 0.06 * viewport.y;\n                float radDiff = abs(projectedRadius - radius) - lineWidth;\n                float alpha = 1.0 - clamp(radDiff / 5.0, 0.0, 1.0); \n\n                gl_FragColor = vec4(color.rgb, alpha * opacity);\n            }\n        ",transparent:!0,depthTest:!1,depthWrite:!1,side:r.FrontSide})}}const R=new r.Vector3(1,0,0),E=new r.Vector3(0,1,0),k=new r.Vector3(0,0,1);class I{constructor(e=new r.Vector3,t=new r.Vector3){this.origin=new r.Vector3,this.direction=new r.Vector3,this.setParameters(e,t)}setParameters(e,t){this.origin.copy(e),this.direction.copy(t).normalize()}boxContainsPoint(e,t,n){return!(t.x<e.min.x-n||t.x>e.max.x+n||t.y<e.min.y-n||t.y>e.max.y+n||t.z<e.min.z-n||t.z>e.max.z+n)}intersectBox=function(){const e=new r.Vector3,t=[],n=[],s=[];return function(r,o){if(n[0]=this.origin.x,n[1]=this.origin.y,n[2]=this.origin.z,s[0]=this.direction.x,s[1]=this.direction.y,s[2]=this.direction.z,this.boxContainsPoint(r,this.origin,1e-4))return o&&(o.origin.copy(this.origin),o.normal.set(0,0,0),o.distance=-1),!0;for(let i=0;i<3;i++){if(0==s[i])continue;const a=0==i?R:1==i?E:k,c=s[i]<0?r.max:r.min;let l=-Math.sign(s[i]);t[0]=0==i?c.x:1==i?c.y:c.z;let h=t[0]-n[i];if(h*l<0){const c=(i+1)%3,d=(i+2)%3;if(t[2]=s[c]/s[i]*h+n[c],t[1]=s[d]/s[i]*h+n[d],e.set(t[i],t[d],t[c]),this.boxContainsPoint(r,e,1e-4))return o&&(o.origin.copy(e),o.normal.copy(a).multiplyScalar(l),o.distance=e.sub(this.origin).length()),!0}}return!1}}();intersectSphere=function(){const e=new r.Vector3;return function(t,n,r){e.copy(t).sub(this.origin);const s=e.dot(this.direction),o=s*s,i=e.dot(e)-o,a=n*n;if(i>a)return!1;const c=Math.sqrt(a-i),l=s-c,h=s+c;if(h<0)return!1;let d=l<0?h:l;return r&&(r.origin.copy(this.origin).addScaledVector(this.direction,d),r.normal.copy(r.origin).sub(t).normalize(),r.distance=d),!0}}()}class _{constructor(){this.origin=new r.Vector3,this.normal=new r.Vector3,this.distance=0}set(e,t,n){this.origin.copy(e),this.normal.copy(t),this.distance=n}clone(){const e=new _;return e.origin.copy(this.origin),e.normal.copy(this.normal),e.distance=this.distance,e}}class V{constructor(e,t){this.ray=new I(e,t)}setFromCameraAndScreenPosition=function(){const e=new r.Vector2;return function(t,n,r){if(e.x=n.x/r.x*2-1,e.y=(r.y-n.y)/r.y*2-1,t.isPerspectiveCamera)this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t;else{if(!t.isOrthographicCamera)throw new Error("Raycaster::setFromCameraAndScreenPosition() -> Unsupported camera type");this.ray.origin.set(n.x,n.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t}}}();intersectSplatMesh=function(){const e=new r.Matrix4,t=new r.Matrix4,n=new I;return function(r,s=[]){t.copy(r.matrixWorld),e.copy(t).invert(),n.origin.copy(this.ray.origin).applyMatrix4(e),n.direction.copy(this.ray.direction).transformDirection(e);const o=r.getSplatTree();return o.rootNode&&this.castRayAtSplatTreeNode(n,o,o.rootNode,s),s.sort(((e,t)=>e.distance>t.distance?1:-1)),s.forEach((e=>{e.origin.applyMatrix4(t),e.normal.transformDirection(t)})),s}}();castRayAtSplatTreeNode=function(){const e=new r.Vector3,t=new r.Vector3,n=new r.Quaternion,s=new _,o=1e-7;return function(r,i,a,c=[]){if(r.intersectBox(a.boundingBox)){if(a.data.indexes&&a.data.indexes.length>0)for(let l=0;l<a.data.indexes.length;l++){const h=a.data.indexes[l],d=i.getSplatLocalIndex(h),p=i.getSplatBufferForSplat(h),u=i.getTransformForSplat(h);if(p.getCenter(d,e,u),p.getScaleAndRotation(d,t,n,u),t.x<=o||t.y<=o||t.z<=o)continue;const m=(t.x+t.y+t.z)/3;r.intersectSphere(e,m,s)&&c.push(s.clone())}if(a.children&&a.children.length>0)for(let e of a.children)this.castRayAtSplatTreeNode(r,i,e,c);return c}}}()}let z=0;class U{constructor(e,t,n,s){this.min=(new r.Vector3).copy(e),this.max=(new r.Vector3).copy(t),this.boundingBox=new r.Box3(this.min,this.max),this.center=(new r.Vector3).copy(this.max).sub(this.min).multiplyScalar(.5).add(this.min),this.depth=n,this.children=[],this.data=null,this.id=s||z++}}class L{constructor(e,t){this.maxDepth=e,this.maxCentersPerNode=t,this.splatMesh=[],this.sceneDimensions=new r.Vector3,this.sceneMin=new r.Vector3,this.sceneMax=new r.Vector3,this.rootNode=null,this.addedIndexes={},this.nodesWithIndexes=[],this.globalSplatIndexToLocalSplatIndexMap={},this.globalSplatIndexToSplatBufferIndexMap={}}getSplatBufferForSplat(e){return this.splatMesh.splatBuffers[this.globalSplatIndexToSplatBufferIndexMap[e]]}getTransformForSplat(e){return this.splatMesh.splatTransforms[this.globalSplatIndexToSplatBufferIndexMap[e]]}getSplatLocalIndex(e){return this.globalSplatIndexToLocalSplatIndexMap[e]}processSplatMesh(e,t=(()=>!0)){const n=new r.Vector3;this.splatMesh=e,this.sceneMin=new r.Vector3,this.sceneMax=new r.Vector3,this.addedIndexes={},this.nodesWithIndexes=[],this.globalSplatIndexToLocalSplatIndexMap={},this.globalSplatIndexToSplatBufferIndexMap={};let s=0,o=0;for(let e=0;e<this.splatMesh.splatBuffers.length;e++){const r=this.splatMesh.splatBuffers[e],i=r.getSplatCount(),a=this.splatMesh.splatTransforms[e];for(let c=0;c<i;c++)t(e,r,c,a)&&(r.getCenter(c,n,a),(0===o||n.x<this.sceneMin.x)&&(this.sceneMin.x=n.x),(0===o||n.x>this.sceneMax.x)&&(this.sceneMax.x=n.x),(0===o||n.y<this.sceneMin.y)&&(this.sceneMin.y=n.y),(0===o||n.y>this.sceneMax.y)&&(this.sceneMax.y=n.y),(0===o||n.z<this.sceneMin.z)&&(this.sceneMin.z=n.z),(0===o||n.z>this.sceneMax.z)&&(this.sceneMax.z=n.z),o++),this.globalSplatIndexToLocalSplatIndexMap[s]=c,this.globalSplatIndexToSplatBufferIndexMap[s]=e,s++}this.sceneDimensions.copy(this.sceneMin).sub(this.sceneMin);const i=[];for(let e=0;e<s;e++){const n=this.getSplatLocalIndex(e);t(this.globalSplatIndexToSplatBufferIndexMap[e],this.getSplatBufferForSplat(e),n,this.getTransformForSplat(e))&&i.push(e)}this.rootNode=new U(this.sceneMin,this.sceneMax,0),this.rootNode.data={indexes:i},this.processNode(this.rootNode,e)}processNode(e,t){const n=e.data.indexes.length;if(n<this.maxCentersPerNode||e.depth>this.maxDepth){const t=[];for(let n=0;n<e.data.indexes.length;n++)this.addedIndexes[e.data.indexes[n]]||(t.push(e.data.indexes[n]),this.addedIndexes[e.data.indexes[n]]=!0);return e.data.indexes=t,void this.nodesWithIndexes.push(e)}const s=(new r.Vector3).copy(e.max).sub(e.min),o=(new r.Vector3).copy(s).multiplyScalar(.5),i=(new r.Vector3).copy(e.min).add(o),a=[new r.Box3(new r.Vector3(i.x-o.x,i.y,i.z-o.z),new r.Vector3(i.x,i.y+o.y,i.z)),new r.Box3(new r.Vector3(i.x,i.y,i.z-o.z),new r.Vector3(i.x+o.x,i.y+o.y,i.z)),new r.Box3(new r.Vector3(i.x,i.y,i.z),new r.Vector3(i.x+o.x,i.y+o.y,i.z+o.z)),new r.Box3(new r.Vector3(i.x-o.x,i.y,i.z),new r.Vector3(i.x,i.y+o.y,i.z+o.z)),new r.Box3(new r.Vector3(i.x-o.x,i.y-o.y,i.z-o.z),new r.Vector3(i.x,i.y,i.z)),new r.Box3(new r.Vector3(i.x,i.y-o.y,i.z-o.z),new r.Vector3(i.x+o.x,i.y,i.z)),new r.Box3(new r.Vector3(i.x,i.y-o.y,i.z),new r.Vector3(i.x+o.x,i.y,i.z+o.z)),new r.Box3(new r.Vector3(i.x-o.x,i.y-o.y,i.z),new r.Vector3(i.x,i.y,i.z+o.z))],c=[],l=[];for(let e=0;e<a.length;e++)c[e]=0,l[e]=[];const h=new r.Vector3;for(let t=0;t<n;t++){const n=e.data.indexes[t],r=this.getSplatLocalIndex(n),s=this.getSplatBufferForSplat(n),o=this.getTransformForSplat(n);s.getCenter(r,h,o);for(let e=0;e<a.length;e++)a[e].containsPoint(h)&&(c[e]++,l[e].push(n))}for(let t=0;t<a.length;t++){const n=new U(a[t].min,a[t].max,e.depth+1);n.data={indexes:l[t]},e.children.push(n)}e.data={};for(let n of e.children)this.processNode(n,t)}countLeaves(){let e=0;return this.visitLeaves((()=>{e++})),e}visitLeaves(e){const t=(e,n)=>{0===e.children.length&&n(e);for(let r of e.children)t(r,n)};return t(this.rootNode,e)}}class O extends r.Mesh{constructor(e=!1,t=1,n=!0){super({morphAttributes:{},fake:!0},null),this.renderer=void 0,this.halfPrecisionCovariancesOnGPU=e,this.devicePixelRatio=t,this.enableDistancesComputationOnGPU=n,this.splatBuffers=[],this.splatTree=null,this.splatDataTextures=null,this.distancesTransformFeedback={id:null,vertexShader:null,fragmentShader:null,program:null,centersBuffer:null,outDistancesBuffer:null,centersLoc:-1,viewProjLoc:-1}}static buildMaterial(){const e={covariancesTexture:{type:"t",value:null},centersColorsTexture:{type:"t",value:null},focal:{type:"v2",value:new r.Vector2},viewport:{type:"v2",value:new r.Vector2},basisViewport:{type:"v2",value:new r.Vector2},debugColor:{type:"v3",value:new r.Color},covariancesTextureSize:{type:"v2",value:new r.Vector2(1024,1024)},centersColorsTextureSize:{type:"v2",value:new r.Vector2(1024,1024)}};return new r.ShaderMaterial({uniforms:e,vertexShader:"\n            precision highp float;\n            #include <common>\n\n            attribute uint splatIndex;\n\n            uniform highp sampler2D covariancesTexture;\n            uniform highp usampler2D centersColorsTexture;\n            uniform vec2 focal;\n            uniform vec2 viewport;\n            uniform vec2 basisViewport;\n            uniform vec2 covariancesTextureSize;\n            uniform vec2 centersColorsTextureSize;\n\n            varying vec4 vColor;\n            varying vec2 vUv;\n\n            varying vec2 vPosition;\n            varying vec2 vSigma;\n\n            const float sqrt2 = sqrt(2.0);\n\n            const vec4 encodeNorm4 = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\n            const uvec4 mask4 = uvec4(uint(0x000000FF), uint(0x0000FF00), uint(0x00FF0000), uint(0xFF000000));\n            const uvec4 shift4 = uvec4(0, 8, 16, 24);\n            vec4 uintToRGBAVec (uint u) {\n               uvec4 urgba = mask4 & u;\n               urgba = urgba >> shift4;\n               vec4 rgba = vec4(urgba) * encodeNorm4;\n               return rgba;\n            }\n\n            vec2 getDataUV(in int stride, in int offset, in vec2 dimensions) {\n                vec2 samplerUV = vec2(0.0, 0.0);\n                float d = float(splatIndex * uint(stride) + uint(offset)) / dimensions.x;\n                samplerUV.y = float(floor(d)) / dimensions.y;\n                samplerUV.x = fract(d);\n                return samplerUV;\n            }\n\n            void main () {\n                uvec4 sampledCenterColor = texture(centersColorsTexture, getDataUV(1, 0, centersColorsTextureSize));\n                vec3 splatCenter = uintBitsToFloat(uvec3(sampledCenterColor.gba));\n                vColor = uintToRGBAVec(sampledCenterColor.r);\n\n                vPosition = position.xy;\n\n                vec4 viewCenter = modelViewMatrix * vec4(splatCenter, 1.0);\n                vec4 clipCenter = projectionMatrix * viewCenter;\n\n                vec2 sampledCovarianceA = texture(covariancesTexture, getDataUV(3, 0, covariancesTextureSize)).rg;\n                vec2 sampledCovarianceB = texture(covariancesTexture, getDataUV(3, 1, covariancesTextureSize)).rg;\n                vec2 sampledCovarianceC = texture(covariancesTexture, getDataUV(3, 2, covariancesTextureSize)).rg;\n\n                vec3 cov3D_M11_M12_M13 = vec3(sampledCovarianceA.rg, sampledCovarianceB.r);\n                vec3 cov3D_M22_M23_M33 = vec3(sampledCovarianceB.g, sampledCovarianceC.rg);\n\n                // Compute the 2D covariance matrix from the upper-right portion of the 3D covariance matrix\n                mat3 Vrk = mat3(\n                    cov3D_M11_M12_M13.x, cov3D_M11_M12_M13.y, cov3D_M11_M12_M13.z,\n                    cov3D_M11_M12_M13.y, cov3D_M22_M23_M33.x, cov3D_M22_M23_M33.y,\n                    cov3D_M11_M12_M13.z, cov3D_M22_M23_M33.y, cov3D_M22_M23_M33.z\n                );\n                float s = 1.0 / (viewCenter.z * viewCenter.z);\n                mat3 J = mat3(\n                    focal.x / viewCenter.z, 0., -(focal.x * viewCenter.x) * s,\n                    0., focal.y / viewCenter.z, -(focal.y * viewCenter.y) * s,\n                    0., 0., 0.\n                );\n                mat3 W = transpose(mat3(modelViewMatrix));\n                mat3 T = W * J;\n                mat3 cov2Dm = transpose(T) * Vrk * T;\n                // cov2Dm[0][0] += 0.3;\n                // cov2Dm[1][1] += 0.3;\n\n                // We are interested in the upper-left 2x2 portion of the projected 3D covariance matrix because\n                // we only care about the X and Y values. We want the X-diagonal, cov2Dm[0][0],\n                // the Y-diagonal, cov2Dm[1][1], and the correlation between the two cov2Dm[0][1]. We don't\n                // need cov2Dm[1][0] because it is a symetric matrix.\n                vec3 cov2Dv = vec3(cov2Dm[0][0], cov2Dm[0][1], cov2Dm[1][1]);\n\n                vec3 ndcCenter = clipCenter.xyz / clipCenter.w;\n\n                // We now need to solve for the eigen-values and eigen vectors of the 2D covariance matrix\n                // so that we can determine the 2D basis for the splat. This is done using the method described\n                // here: https://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html\n                //\n                // This is a different approach than in the original work at INRIA. In that work they compute the\n                // max extents of the 2D covariance matrix in screen space to form an axis aligned bounding rectangle\n                // which forms the geometry that is actually rasterized. They then use the inverse 2D covariance\n                // matrix (called 'conic') to determine fragment opacity.\n                float a = cov2Dv.x;\n                float b = cov2Dv.y;\n                float c = cov2Dv.z;\n                float D = a * c - b * b;\n                float trace = a + c;\n                float traceOver2 = 0.5 * trace;\n                float term2 = sqrt(trace * trace / 4.0 - D);\n                float eigenValue1 = traceOver2 + term2;\n                float eigenValue2 = traceOver2 - term2; // prevent negative eigen value\n                float sigma1 = sqrt(eigenValue1);\n                float sigma2 = sqrt(max(eigenValue2, 0.00));\n                vSigma = vec2(sigma1, sigma2);\n\n                const float maxSplatSize = 1024.0;\n                vec2 eigenVector1 = normalize(vec2(b, eigenValue1 - a));\n                // since the eigen vectors are orthogonal, we derive the second one from the first\n                // vec2 eigenVector2 = vec2(eigenVector1.y, -eigenVector1.x);\n                vec2 eigenVector2 = normalize(vec2(eigenValue2 - c, b));\n                vec2 basisVector1 = eigenVector1 * min(3.0 * sigma1, maxSplatSize);\n                vec2 basisVector2 = eigenVector2 * min(3.0 * sigma2, maxSplatSize);\n\n                vec2 ndcOffset = vec2(vPosition.x * basisVector1 + vPosition.y * basisVector2) * basisViewport * 2.0;\n\n                gl_Position = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);\n            }",fragmentShader:"\n            precision highp float;\n            #include <common>\n\n            uniform vec3 debugColor;\n\n            varying vec4 vColor;\n            varying vec2 vUv;\n\n            varying vec2 vPosition;\n            varying vec2 vSigma;\n            \n            const float M_2PIf = 6.28318530717958647692;\n\n            void main () {\n                // compute the negative squared distance from the center of the splat to the\n                // current fragment in the splat's local space.\n                float A = dot(vPosition, vPosition);\n                if (A > 1.0) discard;\n                vec3 color = vColor.rgb;\n\n                float sigma1 = vSigma.x;\n                float sigma2 = vSigma.y;\n                float U2 = 3.0 * vPosition.x + 0.5 / sigma1;\n                float U1 = 3.0 * vPosition.x - 0.5 / sigma1;\n                float cdfU1 = 1.0 / (1.0 + exp(-1.6 * U1 - 0.07 * U1 * U1 * U1));\n                float cdfU2 = 1.0 / (1.0 + exp(-1.6 * U2 - 0.07 * U2 * U2 * U2));\n                float intU = sigma1 * (cdfU2 - cdfU1);\n                float V2 = 3.0 * vPosition.y + 0.5 / sigma2;\n                float V1 = 3.0 * vPosition.y - 0.5 / sigma2;\n                float cdfV1 = 1.0 / (1.0 + exp(-1.6 * V1 - 0.07 * V1 * V1 * V1));\n                float cdfV2 = 1.0 / (1.0 + exp(-1.6 * V2 - 0.07 * V2 * V2 * V2));\n                float intV = sigma2 * (cdfV2 - cdfV1);\n                float integral = M_2PIf * intU * intV;\n\n                A = integral * vColor.a;\n                // A = min(0.99, A);\n                // if (A < 1.0 / 255.0) A = 0.0;\n                // A = exp(A) * vColor.a;\n                gl_FragColor = vec4(color.rgb, A);\n            }",transparent:!0,alphaTest:1,blending:r.NormalBlending,depthTest:!0,depthWrite:!1,side:r.DoubleSide})}static buildGeomtery(e){let t=O.getTotalSplatCount(e);const n=new r.BufferGeometry;n.setIndex([0,1,2,0,2,3]);const s=new Float32Array(12),o=new r.BufferAttribute(s,3);n.setAttribute("position",o),o.setXYZ(0,-1,-1,0),o.setXYZ(1,-1,1,0),o.setXYZ(2,1,1,0),o.setXYZ(3,1,-1,0),o.needsUpdate=!0;const i=(new r.InstancedBufferGeometry).copy(n),a=new Uint32Array(t),c=new r.InstancedBufferAttribute(a,1,!1);return c.setUsage(r.DynamicDrawUsage),i.setAttribute("splatIndex",c),i.instanceCount=t,i}dispose(){this.disposeMeshData(),this.enableDistancesComputationOnGPU&&this.disposeGPUResources()}disposeMeshData(){this.geometry&&!this.geometry.fake&&(this.geometry.dispose(),this.geometry=null);for(let e in this.splatDataTextures)if(this.splatDataTextures.hasOwnProperty(e)){const t=this.splatDataTextures[e];t.texture&&(t.texture.dispose(),t.texture=null)}this.splatDataTextures=null,this.material&&(this.material.dispose(),this.material=null),this.splatTree=null}build(e,t){this.disposeMeshData(),this.splatBuffers=e,this.splatBufferOptions=t,this.buildSplatTransforms(),this.geometry=O.buildGeomtery(this.splatBuffers),this.material=O.buildMaterial(),this.buildSplatTree(),this.enableDistancesComputationOnGPU&&this.setupDistancesTransformFeedback(),this.resetLocalSplatDataAndTexturesFromSplatBuffer()}buildSplatTransforms(){this.splatTransforms=[];for(let e of this.splatBufferOptions)if(e){let t=e.position||[0,0,0],n=e.rotation||[0,0,0,1],s=e.scale||[1,1,1];const o=(new r.Vector3).fromArray(t),i=(new r.Quaternion).fromArray(n),a=(new r.Vector3).fromArray(s),c=new r.Matrix4;c.compose(o,i,a),this.splatTransforms.push(c)}}buildSplatTree(){this.splatTree=new L(8,1e3),console.time("SplatTree build");const e=new r.Vector4;this.splatTree.processSplatMesh(this,((t,n,r,s)=>{n.getColor(r,e,s);const o=this.splatBufferOptions[t];return e.w>(o.splatAlphaRemovalThreshold||1)})),console.timeEnd("SplatTree build");let t=0,n=0,s=0,o=0;this.splatTree.visitLeaves((e=>{const r=e.data.indexes.length;r>0&&(n+=r,s=Math.max(s,r),o++,t++)})),console.log(`SplatTree leaves: ${this.splatTree.countLeaves()}`),console.log(`SplatTree leaves with splats:${t}`),n/=o,console.log(`Avg splat count per node: ${n}`)}getSplatTree(){return this.splatTree}resetLocalSplatDataAndTexturesFromSplatBuffer(){this.updateLocalSplatDataFromSplatBuffer(),this.allocateAndStoreLocalSplatDataInTextures(),this.enableDistancesComputationOnGPU&&this.updateCentersGPUBufferForDistancesComputation()}updateLocalSplatDataFromSplatBuffer(){const e=this.getSplatCount();this.covariances=new Float32Array(6*e),this.centers=new Float32Array(3*e),this.colors=new Uint8Array(4*e);let t=0;for(let e=0;e<this.splatBuffers.length;e++){const n=this.splatBuffers[e],r=this.splatTransforms[e];n.fillCovarianceArray(this.covariances,t,r),n.fillCenterArray(this.centers,t,r),n.fillColorArray(this.colors,t,r),t+=n.getSplatCount()}}allocateAndStoreLocalSplatDataInTextures(){const e=this.getSplatCount(),t=new r.Vector2(4096,1024);for(;t.x*t.y*2<6*e;)t.y*=2;const n=new r.Vector2(4096,1024);for(;n.x*n.y*4<4*e;)n.y*=2;let o,i;if(this.halfPrecisionCovariancesOnGPU){i=new Uint16Array(t.x*t.y*2);for(let e=0;e<this.covariances.length;e++)i[e]=r.DataUtils.toHalfFloat(this.covariances[e]);o=new r.DataTexture(i,t.x,t.y,r.RGFormat,r.HalfFloatType)}else i=new Float32Array(t.x*t.y*2),i.set(this.covariances),o=new r.DataTexture(i,t.x,t.y,r.RGFormat,r.FloatType);o.needsUpdate=!0,this.material.uniforms.covariancesTexture.value=o,this.material.uniforms.covariancesTextureSize.value.copy(t);const a=new Uint32Array(n.x*n.y*4);for(let t=0;t<e;t++){const e=4*t,n=3*t,r=4*t;a[r]=(c=this.colors[e],l=this.colors[e+1],h=this.colors[e+2],d=this.colors[e+3],c+(l<<8)+(h<<16)+(d<<24)),a[r+1]=s(this.centers[n]),a[r+2]=s(this.centers[n+1]),a[r+3]=s(this.centers[n+2])}var c,l,h,d;const p=new r.DataTexture(a,n.x,n.y,r.RGBAIntegerFormat,r.UnsignedIntType);p.internalFormat="RGBA32UI",p.needsUpdate=!0,this.material.uniforms.centersColorsTexture.value=p,this.material.uniforms.centersColorsTextureSize.value.copy(n),this.material.uniformsNeedUpdate=!0,this.splatDataTextures={covariances:{data:i,texture:o,size:t},centerColors:{data:a,texture:p,size:n}}}updateSplatDataToDataTextures(){this.updateLocalCovarianceDataToDataTexture(),this.updateLocalCenterColorDataToDataTexture()}updateLocalCovarianceDataToDataTexture(){this.splatDataTextures.covariances.data.set(this.covariances),this.splatDataTextures.covariances.texture.needsUpdate=!0}updateLocalCenterColorDataToDataTexture(){this.splatDataTextures.centerColors.data.set(this.centerColors),this.splatDataTextures.centerColors.texture.needsUpdate=!0}updateIndexes(e,t){const n=this.geometry;n.attributes.splatIndex.set(e),n.attributes.splatIndex.needsUpdate=!0,n.instanceCount=t}updateUniforms=function(){const e=new r.Vector2;return function(t,n,r){this.getSplatCount()>0&&(e.set(t.x*this.devicePixelRatio,t.y*this.devicePixelRatio),this.material.uniforms.viewport.value.copy(e),this.material.uniforms.basisViewport.value.set(1/e.x,1/e.y),this.material.uniforms.focal.value.set(n,r),this.material.uniformsNeedUpdate=!0)}}();getSplatDataTextures(){return this.splatDataTextures}getSplatCount(){return O.getTotalSplatCount(this.splatBuffers)}static getTotalSplatCount(e){let t=0;for(let n of e)t+=n.getSplatCount();return t}disposeGPUResources(){if(!this.renderer)return;const e=this.renderer.getContext();this.distancesTransformFeedback.vao&&(e.deleteVertexArray(this.distancesTransformFeedback.vao),this.distancesTransformFeedback.vao=null),this.distancesTransformFeedback.program&&(e.deleteProgram(this.distancesTransformFeedback.program),e.deleteShader(this.distancesTransformFeedback.vertexShader),e.deleteShader(this.distancesTransformFeedback.fragmentShader),this.distancesTransformFeedback.program=null,this.distancesTransformFeedback.vertexShader=null,this.distancesTransformFeedback.fragmentShader=null),this.disposeGPUBufferResources(),this.distancesTransformFeedback.id&&(e.deleteTransformFeedback(this.distancesTransformFeedback.id),this.distancesTransformFeedback.id=null)}disposeGPUBufferResources(){if(!this.renderer)return;const e=this.renderer.getContext();this.distancesTransformFeedback.centersBuffer&&(this.distancesTransformFeedback.centersBuffer=null,e.deleteBuffer(this.distancesTransformFeedback.centersBuffer)),this.distancesTransformFeedback.outDistancesBuffer&&(e.deleteBuffer(this.distancesTransformFeedback.outDistancesBuffer),this.distancesTransformFeedback.outDistancesBuffer=null)}setRenderer(e){e!==this.renderer&&(this.renderer=e,this.enableDistancesComputationOnGPU&&this.getSplatCount()>0&&(this.setupDistancesTransformFeedback(),this.updateCentersGPUBufferForDistancesComputation()))}setupDistancesTransformFeedback=function(){let e,t;return function(){const n=this.getSplatCount();if(!this.renderer||e===this.renderer&&t===n)return;const r=e!==this.renderer,s=t!==n;r?this.disposeGPUResources():s&&this.disposeGPUBufferResources();const o=this.renderer.getContext(),i=(e,t,n)=>{const r=e.createShader(t);if(!r)return console.error("Fatal error: gl could not create a shader object."),null;e.shaderSource(r,n),e.compileShader(r);if(!e.getShaderParameter(r,e.COMPILE_STATUS)){let n="unknown";t===e.VERTEX_SHADER?n="vertex shader":t===e.FRAGMENT_SHADER&&(n="fragement shader");const s=e.getShaderInfoLog(r);return console.error("Failed to compile "+n+" with these errors:"+s),e.deleteShader(r),null}return r},a=o.getParameter(o.VERTEX_ARRAY_BINDING),c=o.getParameter(o.CURRENT_PROGRAM);if(r&&(this.distancesTransformFeedback.vao=o.createVertexArray()),o.bindVertexArray(this.distancesTransformFeedback.vao),r){const e=o.createProgram(),t=i(o,o.VERTEX_SHADER,"#version 300 es\n                in ivec3 center;\n                uniform ivec3 viewProj;\n                flat out int distance;\n                void main(void) {\n                    distance = center.x * viewProj.x + center.y * viewProj.y + center.z * viewProj.z;\n                }\n            "),n=i(o,o.FRAGMENT_SHADER,"#version 300 es\n                precision lowp float;\n                out vec4 fragColor;\n                void main(){}\n            ");if(!t||!n)throw new Error("Could not compile shaders for distances computation on GPU.");o.attachShader(e,t),o.attachShader(e,n),o.transformFeedbackVaryings(e,["distance"],o.SEPARATE_ATTRIBS),o.linkProgram(e);if(!o.getProgramParameter(e,o.LINK_STATUS)){const r=o.getProgramInfoLog(e);throw console.error("Fatal error: Failed to link program: "+r),o.deleteProgram(e),o.deleteShader(n),o.deleteShader(t),new Error("Could not link shaders for distances computation on GPU.")}this.distancesTransformFeedback.program=e,this.distancesTransformFeedback.vertexShader=t,this.distancesTransformFeedback.vertexShader=n}o.useProgram(this.distancesTransformFeedback.program),this.distancesTransformFeedback.centersLoc=o.getAttribLocation(this.distancesTransformFeedback.program,"center"),this.distancesTransformFeedback.viewProjLoc=o.getUniformLocation(this.distancesTransformFeedback.program,"viewProj"),(r||s)&&(this.distancesTransformFeedback.centersBuffer=o.createBuffer(),o.bindBuffer(o.ARRAY_BUFFER,this.distancesTransformFeedback.centersBuffer),o.enableVertexAttribArray(this.distancesTransformFeedback.centersLoc),o.vertexAttribIPointer(this.distancesTransformFeedback.centersLoc,3,o.INT,0,0)),(r||s)&&(this.distancesTransformFeedback.outDistancesBuffer=o.createBuffer()),o.bindBuffer(o.ARRAY_BUFFER,this.distancesTransformFeedback.outDistancesBuffer),o.bufferData(o.ARRAY_BUFFER,4*n,o.DYNAMIC_COPY),r&&(this.distancesTransformFeedback.id=o.createTransformFeedback()),o.bindTransformFeedback(o.TRANSFORM_FEEDBACK,this.distancesTransformFeedback.id),o.bindBufferBase(o.TRANSFORM_FEEDBACK_BUFFER,0,this.distancesTransformFeedback.outDistancesBuffer),c&&o.useProgram(c),a&&o.bindVertexArray(a),e=this.renderer,t=n}}();getIntegerCenters(e){const t=this.getSplatCount(),n=new Float32Array(this.centers);let r,s=e?4:3;r=new Int32Array(t*s);for(let o=0;o<t;o++){for(let e=0;e<3;e++)r[o*s+e]=Math.round(1e3*n[3*o+e]);e&&(r[o*s+3]=1)}return r}getIntegerMatrixArray(e){const t=e.elements,n=[];for(let e=0;e<16;e++)n[e]=Math.round(1e3*t[e]);return n}updateCentersGPUBufferForDistancesComputation(){if(!this.renderer)return;const e=this.renderer.getContext(),t=e.getParameter(e.VERTEX_ARRAY_BINDING);e.bindVertexArray(this.distancesTransformFeedback.vao);const n=this.getIntegerCenters(!1);e.bindBuffer(e.ARRAY_BUFFER,this.distancesTransformFeedback.centersBuffer),e.bufferData(e.ARRAY_BUFFER,n,e.STATIC_DRAW),t&&e.bindVertexArray(t)}computeDistancesOnGPU(e,t){if(!this.renderer)return;const n=this.getIntegerMatrixArray(e),r=[n[2],n[6],n[10]],s=this.renderer.getContext(),o=s.getParameter(s.VERTEX_ARRAY_BINDING),i=s.getParameter(s.CURRENT_PROGRAM);s.bindVertexArray(this.distancesTransformFeedback.vao),s.useProgram(this.distancesTransformFeedback.program),s.enable(s.RASTERIZER_DISCARD),s.uniform3i(this.distancesTransformFeedback.viewProjLoc,r[0],r[1],r[2]),s.bindBuffer(s.ARRAY_BUFFER,this.distancesTransformFeedback.centersBuffer),s.enableVertexAttribArray(this.distancesTransformFeedback.centersLoc),s.vertexAttribIPointer(this.distancesTransformFeedback.centersLoc,3,s.INT,0,0),s.bindTransformFeedback(s.TRANSFORM_FEEDBACK,this.distancesTransformFeedback.id),s.bindBufferBase(s.TRANSFORM_FEEDBACK_BUFFER,0,this.distancesTransformFeedback.outDistancesBuffer),s.beginTransformFeedback(s.POINTS),s.drawArrays(s.POINTS,0,this.getSplatCount()),s.endTransformFeedback(),s.bindBufferBase(s.TRANSFORM_FEEDBACK_BUFFER,0,null),s.bindTransformFeedback(s.TRANSFORM_FEEDBACK,null),s.disable(s.RASTERIZER_DISCARD),s.bindBuffer(s.ARRAY_BUFFER,this.distancesTransformFeedback.outDistancesBuffer),s.getBufferSubData(s.ARRAY_BUFFER,0,t),s.bindBuffer(s.ARRAY_BUFFER,null),i&&s.useProgram(i),o&&s.bindVertexArray(o)}}class N{static DepthMapRange=65536;static MemoryPageSize=65536;static BytesPerFloat=4;static BytesPerInt=4}function j(e){let t,n,r,s,o,i,a,c,l,h,d,p;e.onmessage=u=>{if(u.data.centers)centers=u.data.centers,new Int32Array(n,l,4*r).set(new Int32Array(centers)),e.postMessage({sortSetupComplete:!0});else if(u.data.sort){const m=u.data.sort.splatRenderCount||0;!function(u,m,f,y){const g=performance.now();d||(d=new Uint32Array(p.DepthMapRange)),new Int32Array(n,h,16).set(f),new Uint32Array(n,c,p.DepthMapRange).set(d),t.exports.sortIndexes(s,l,i,a,c,h,o,p.DepthMapRange,u,m,r,y);const C=performance.now();e.postMessage({sortDone:!0,splatSortCount:u,splatRenderCount:m,sortTime:C-g})}(u.data.sort.splatSortCount||0,m,u.data.sort.viewProj,u.data.sort.usePrecomputedDistances)}else if(u.data.init){p=u.data.init.Constants,r=u.data.init.splatCount;const d=4*p.BytesPerInt,m=new Uint8Array(u.data.init.sorterWasmBytes),f=r*p.BytesPerInt,y=r*d,g=16*p.BytesPerFloat,C=r*p.BytesPerInt,A=r*p.BytesPerInt,v=r*p.BytesPerInt,w=p.DepthMapRange*p.BytesPerInt*2,x=32*p.MemoryPageSize,b=f+y+g+C+A+v+w+x,S=Math.floor(b/p.MemoryPageSize)+1,M={module:{},env:{memory:new WebAssembly.Memory({initial:2*S,maximum:4*S,shared:!0})}};WebAssembly.compile(m).then((e=>WebAssembly.instantiate(e,M))).then((r=>{t=r,s=0,l=s+f,h=l+y,i=h+g,a=i+C,c=a+A,o=c+w,n=M.env.memory.buffer,e.postMessage({sortSetupPhase1Complete:!0,indexesToSortBuffer:n,indexesToSortOffset:s,sortedIndexesBuffer:n,sortedIndexesOffset:o,precomputedDistancesBuffer:n,precomputedDistancesOffset:i})}))}}}function H(e){const t=new Worker(URL.createObjectURL(new Blob(["(",j.toString(),")(self)"],{type:"application/javascript"}))),n=atob("AGFzbQEAAAAADAZkeWxpbmsAAAAAAAEXA2AAAGAMf39/f39/f39/f39/AGAAAX8CEgEDZW52Bm1lbW9yeQIDAICABAMEAwABAgc5AxFfX3dhc21fY2FsbF9jdG9ycwAAC3NvcnRJbmRleGVzAAETZW1zY3JpcHRlbl90bHNfaW5pdAACCtUEAwMAAQvJBAICewJ9IAkgCGshCgJAIAsEQEH4////ByELQYiAgIB4IQggCSAKTQ0BIAohBQNAIAMgBUECdCIBaiACIAAgAWooAgBBAnRqKAIAIgE2AgAgASALIAEgC0gbIQsgASAIIAEgCEobIQggBUEBaiIFIAlHDQALDAELQfj///8HIQtBiICAgHghCCAJIApNDQAgBUEoaiAFQRhqIAX9CQII/VYCAAH9VgIAAiENIAohBQNAIAMgBUECdCICaiABIAAgAmooAgBBBHRq/QAAACAN/bUBIgz9GwAgDP0bAWogDP0bAmoiAjYCACACIAsgAiALSBshCyACIAggAiAIShshCCAFQQFqIgUgCUcNAAsLIAkgCksEQCAHQQFrsyAIsiALspOVIQ4gCiEIA0ACfyAOIAMgCEECdGoiASgCACALa7KUIg+LQwAAAE9dBEAgD6gMAQtBgICAgHgLIQUgASAFNgIAIAQgBUECdGoiASABKAIAQQFqNgIAIAhBAWoiCCAJRw0ACwsgB0ECTwRAIAQoAgAhCEEBIQsDQCAEIAtBAnRqIgEgASgCACAIaiIINgIAIAtBAWoiCyAHRw0ACwsgCkEASgRAIAohCwNAIAYgC0EBayIBQQJ0IgJqIAAgAmooAgA2AgAgC0EBSiECIAEhCyACDQALCyAJIApKBEAgCSELA0AgBiAJIAQgAyALQQFrIgtBAnQiAWooAgBBAnRqIgIoAgAiBWtBAnRqIAAgAWooAgA2AgAgAiAFQQFrNgIAIAogC0gNAAsLCwQAQQAL"),r=new Uint8Array(n.length);for(let e=0;e<n.length;e++)r[e]=n.charCodeAt(e);return t.postMessage({init:{sorterWasmBytes:r.buffer,splatCount:e,Constants:{BytesPerFloat:N.BytesPerFloat,BytesPerInt:N.BytesPerInt,DepthMapRange:N.DepthMapRange,MemoryPageSize:N.MemoryPageSize}}}),t}class W{constructor(e={}){e.cameraUp||(e.cameraUp=[0,1,0]),e.initialCameraPosition||(e.initialCameraPosition=[0,10,15]),e.initialCameraLookAt||(e.initialCameraLookAt=[0,0,0]),void 0===e.selfDrivenMode&&(e.selfDrivenMode=!0),void 0===e.useBuiltInControls&&(e.useBuiltInControls=!0),this.rootElement=e.rootElement,this.ignoreDevicePixelRatio=e.ignoreDevicePixelRatio||!1,this.devicePixelRatio=this.ignoreDevicePixelRatio?1:window.devicePixelRatio,void 0===e.halfPrecisionCovariancesOnGPU&&(e.halfPrecisionCovariancesOnGPU=!0),this.halfPrecisionCovariancesOnGPU=e.halfPrecisionCovariancesOnGPU,this.cameraUp=(new r.Vector3).fromArray(e.cameraUp),this.initialCameraPosition=(new r.Vector3).fromArray(e.initialCameraPosition),this.initialCameraLookAt=(new r.Vector3).fromArray(e.initialCameraLookAt),this.scene=e.scene,this.renderer=e.renderer,this.camera=e.camera,this.useBuiltInControls=e.useBuiltInControls,this.controls=null,this.selfDrivenMode=e.selfDrivenMode,this.selfDrivenUpdateFunc=this.selfDrivenUpdate.bind(this),this.gpuAcceleratedSort=e.gpuAcceleratedSort,!0!==this.gpuAcceleratedSort&&!1!==this.gpuAcceleratedSort&&(this.isMobile()?this.gpuAcceleratedSort=!1:this.gpuAcceleratedSort=!0),this.showMeshCursor=!1,this.showControlPlane=!1,this.showInfo=!1,this.sceneHelper=null,this.sortWorker=null,this.sortRunning=!1,this.splatRenderCount=0,this.sortWorkerIndexesToSort=null,this.sortWorkerSortedIndexes=null,this.sortWorkerPrecomputedDistances=null,this.splatMesh=null,this.selfDrivenModeRunning=!1,this.splatRenderingInitialized=!1,this.raycaster=new V,this.infoPanel=null,this.infoPanelCells={},this.currentFPS=0,this.lastSortTime=0,this.previousCameraTarget=new r.Vector3,this.nextCameraTarget=new r.Vector3,this.mousePosition=new r.Vector2,this.mouseDownPosition=new r.Vector2,this.mouseDownTime=null,this.loadingSpinner=new F(null,this.rootElement||document.body),this.loadingSpinner.hide(),this.usingExternalCamera=void 0,this.usingExternalRenderer=void 0,this.initializeFromExternalUpdate=e.initializeFromExternalUpdate||!1,this.initialized=!1,this.initializeFromExternalUpdate||this.init()}init(){if(this.initialized)return;this.initializeFromExternalUpdate?(this.usingExternalCamera=!0,this.usingExternalRenderer=!0):(this.usingExternalCamera=!!this.camera,this.usingExternalRenderer=!!this.renderer),this.rootElement||(this.usingExternalRenderer?this.rootElement=this.renderer.domElement.parentElement||document.body:(this.rootElement=document.createElement("div"),this.rootElement.style.width="100%",this.rootElement.style.height="100%",this.rootElement.style.position="absolute",document.body.appendChild(this.rootElement)));const e=new r.Vector2;if(this.getRenderDimensions(e),this.usingExternalCamera||(this.camera=new r.PerspectiveCamera(50,e.x/e.y,.1,500),this.camera.position.copy(this.initialCameraPosition),this.camera.lookAt(this.initialCameraLookAt),this.camera.up.copy(this.cameraUp).normalize()),this.usingExternalRenderer||(this.renderer=new r.WebGLRenderer({antialias:!1,precision:"highp"}),this.renderer.setPixelRatio(this.devicePixelRatio),this.renderer.autoClear=!0,this.renderer.setClearColor(0,0,0,0),this.renderer.setSize(e.x,e.y)),this.scene=this.scene||new r.Scene,this.sceneHelper=new B(this.scene),this.sceneHelper.setupMeshCursor(),this.sceneHelper.setupFocusMarker(),this.sceneHelper.setupControlPlane(),this.useBuiltInControls&&(this.controls=new T(this.camera,this.renderer.domElement),this.controls.listenToKeyEvents(window),this.controls.rotateSpeed=.5,this.controls.maxPolarAngle=.75*Math.PI,this.controls.minPolarAngle=.1,this.controls.enableDamping=!0,this.controls.dampingFactor=.05,this.controls.target.copy(this.initialCameraLookAt),this.rootElement.addEventListener("pointermove",this.onMouseMove.bind(this),!1),this.rootElement.addEventListener("pointerdown",this.onMouseDown.bind(this),!1),this.rootElement.addEventListener("pointerup",this.onMouseUp.bind(this),!1),window.addEventListener("keydown",this.onKeyDown.bind(this),!1)),!this.usingExternalRenderer){new ResizeObserver((()=>{this.getRenderDimensions(e),this.renderer.setSize(e.x,e.y)})).observe(this.rootElement),this.rootElement.appendChild(this.renderer.domElement)}this.setupInfoPanel(),this.loadingSpinner.setContainer(this.rootElement),this.initialized=!0}onKeyDown=function(){const e=new r.Vector3,t=new r.Matrix4,n=new r.Matrix4;return function(r){switch(e.set(0,0,-1),e.transformDirection(this.camera.matrixWorld),t.makeRotationAxis(e,Math.PI/128),n.makeRotationAxis(e,-Math.PI/128),r.code){case"ArrowLeft":this.camera.up.transformDirection(t);break;case"ArrowRight":this.camera.up.transformDirection(n);break;case"KeyC":this.showMeshCursor=!this.showMeshCursor;break;case"KeyP":this.showControlPlane=!this.showControlPlane;break;case"KeyI":this.showInfo=!this.showInfo,this.showInfo?this.infoPanel.style.display="block":this.infoPanel.style.display="none"}}}();onMouseMove(e){this.mousePosition.set(e.offsetX,e.offsetY)}onMouseDown(){this.mouseDownPosition.copy(this.mousePosition),this.mouseDownTime=a()}onMouseUp=function(){const e=new r.Vector2,t=new r.Vector2,n=new r.Vector3,s=[];return function(r){t.copy(this.mousePosition).sub(this.mouseDownPosition);const o=a()-this.mouseDownTime<.5&&t.length()<2;if(!this.transitioningCameraTarget&&o&&(this.getRenderDimensions(e),s.length=0,this.raycaster.setFromCameraAndScreenPosition(this.camera,this.mousePosition,e),this.mousePosition.set(r.offsetX,r.offsetY),this.raycaster.intersectSplatMesh(this.splatMesh,s),s.length>0)){const e=s[0].origin;n.copy(e).sub(this.camera.position),n.length()>.75&&(this.previousCameraTarget.copy(this.controls.target),this.nextCameraTarget.copy(e),this.transitioningCameraTarget=!0,this.transitioningCameraTargetStartTime=a())}}}();getRenderDimensions(e){this.rootElement?(e.x=this.rootElement.offsetWidth,e.y=this.rootElement.offsetHeight):this.renderer.getSize(e)}setupInfoPanel(){this.infoPanel=document.createElement("div"),this.infoPanel.style.position="absolute",this.infoPanel.style.padding="10px",this.infoPanel.style.backgroundColor="#cccccc",this.infoPanel.style.border="#aaaaaa 1px solid",this.infoPanel.style.zIndex=100,this.infoPanel.style.width="375px",this.infoPanel.style.fontFamily="arial",this.infoPanel.style.fontSize="10pt",this.infoPanel.style.textAlign="left";const e=[["Camera position","cameraPosition"],["Camera look-at","cameraLookAt"],["Camera up","cameraUp"],["Cursor position","cursorPosition"],["FPS","fps"],["Render window","renderWindow"],["Rendering:","renderSplatCount"],["Sort time","sortTime"]],t=document.createElement("div");t.style.display="table";for(let n of e){const e=document.createElement("div");e.style.display="table-row";const r=document.createElement("div");r.style.display="table-cell",r.style.width="110px",r.innerHTML=`${n[0]}: `;const s=document.createElement("div");s.style.display="table-cell",s.style.width="10px",s.innerHTML=" ";const o=document.createElement("div");o.style.display="table-cell",o.innerHTML="",this.infoPanelCells[n[1]]=o,e.appendChild(r),e.appendChild(s),e.appendChild(o),t.appendChild(e)}this.infoPanel.appendChild(t),this.infoPanel.style.display="none",this.renderer.domElement.parentElement.prepend(this.infoPanel)}updateSplatMeshUniforms=function(){const e=new r.Vector2;return function(){if(!this.splatMesh)return;this.splatMesh.getSplatCount()>0&&(this.getRenderDimensions(e),this.cameraFocalLengthX=this.camera.projectionMatrix.elements[0]*this.devicePixelRatio*e.x*.45,this.cameraFocalLengthY=this.camera.projectionMatrix.elements[5]*this.devicePixelRatio*e.y*.45,this.splatMesh.updateUniforms(e,this.cameraFocalLengthX,this.cameraFocalLengthY))}}();loadFile(e,t={}){return!1!==t.showLoadingSpinner&&(t.showLoadingSpinner=!0),new Promise(((n,r)=>{t.showLoadingSpinner&&this.loadingSpinner.show();this.loadFileToSplatBuffer(e,t.splatAlphaRemovalThreshold,((e,n)=>{if(t.showLoadingSpinner)if(100==e)this.loadingSpinner.setMessage("Download complete!");else{const e=n?`: ${n}`:"...";this.loadingSpinner.setMessage(`Downloading${e}`)}t.onProgress&&t.onProgress(e,n,"downloading")})).then((e=>{t.showLoadingSpinner&&this.loadingSpinner.hide(),t.onProgress&&t.onProgress(0,"0%","processing");const r={rotation:t.rotation||t.orientation,position:t.position,scale:t.scale,splatAlphaRemovalThreshold:t.splatAlphaRemovalThreshold};this.loadSplatBuffersIntoMesh([e],[r],t.showLoadingSpinner).then((()=>{t.onProgress&&t.onProgress(100,"100%","processing"),n()}))})).catch((t=>{r(new Error(`Viewer::loadFile -> Could not load file ${e}`))}))}))}loadFiles(e,t=!0,n=void 0){return new Promise(((r,s)=>{const o=e.length,i=[];t&&this.loadingSpinner.show();const a=(e,r,s)=>{i[e]=r;let a=0;for(let e=0;e<o;e++)a+=i[e]||0;a/=o,s=`${a.toFixed(2)}%`,t&&(100==a?this.loadingSpinner.setMessage("Download complete!"):this.loadingSpinner.setMessage(`Downloading: ${s}`)),n&&n(a,s,"downloading")},c=[];for(let t=0;t<e.length;t++){const n=e[t]||{},r=this.loadFileToSplatBuffer(e[t].path,n.splatAlphaRemovalThreshold,a.bind(this,t));c.push(r)}Promise.all(c).then((s=>{t&&this.loadingSpinner.hide(),n&&options.onProgress(0,"0%","processing"),this.loadSplatBuffersIntoMesh(s,e,t).then((()=>{n&&n(100,"100%","processing"),r()}))})).catch((e=>{s(new Error("Viewer::loadFiles -> Could not load one or more files."))}))}))}loadFileToSplatBuffer(e,t=1,n=void 0){const r=(e,t)=>{n&&n(e,t,"downloading")};return new Promise(((n,s)=>{let o;v.isFileSplatFormat(e)?o=(new v).loadFromURL(e,r):e.endsWith(".ply")?o=(new A).loadFromURL(e,r,0,t):s(new Error(`Viewer::loadFileToSplatBuffer -> File format not supported: ${e}`)),o.then((e=>{n(e)})).catch((()=>{s(new Error(`Viewer::loadFileToSplatBuffer -> Could not load file ${e}`))}))}))}loadSplatBuffersIntoMesh=function(){let e,t=0;return function(n,r=[],s=!0){this.splatRenderingInitialized=!1,t++;const o=()=>new Promise((e=>{s&&(this.loadingSpinner.show(),this.loadingSpinner.setMessage("Processing splats...")),window.setTimeout((()=>{this.sortWorker&&this.sortWorker.terminate(),this.sortWorker=null,this.sortRunning=!1,this.updateSplatMesh(n,r),this.setupSortWorker(this.splatMesh).then((()=>{t--,0===t&&(s&&this.loadingSpinner.hide(),this.splatRenderingInitialized=!0,this.updateView(!0,!0)),e()}))}),1)}));return e=e?e.then((()=>o())):o(),e}}();updateSplatMesh(e,t){this.splatMesh||(this.splatMesh=new O(this.halfPrecisionCovariancesOnGPU,this.devicePixelRatio,this.gpuAcceleratedSort));const n=this.splatMesh.splatBuffers||[],r=this.splatMesh.splatBufferOptions||[];n.push(...e),r.push(...t),this.splatMesh.build(n,r),this.renderer&&this.splatMesh.setRenderer(this.renderer);const s=this.splatMesh.getSplatCount();console.log(`Total splat count: ${s}`),this.splatMesh.frustumCulled=!1,this.splatRenderCount=s}setupSortWorker(e){return new Promise((t=>{const n=e.getSplatCount(),r=H(n);r.onmessage=e=>{if(e.data.sortDone)this.sortRunning=!1,this.splatMesh.updateIndexes(this.sortWorkerSortedIndexes,e.data.splatRenderCount),this.lastSortTime=e.data.sortTime;else if(e.data.sortCanceled)this.sortRunning=!1;else if(e.data.sortSetupPhase1Complete){console.log("Sorting web worker WASM setup complete."),r.postMessage({centers:this.splatMesh.getIntegerCenters(!0).buffer}),this.sortWorkerSortedIndexes=new Uint32Array(e.data.sortedIndexesBuffer,e.data.sortedIndexesOffset,n),this.sortWorkerIndexesToSort=new Uint32Array(e.data.indexesToSortBuffer,e.data.indexesToSortOffset,n),this.sortWorkerPrecomputedDistances=new Int32Array(e.data.precomputedDistancesBuffer,e.data.precomputedDistancesOffset,n);for(let e=0;e<n;e++)this.sortWorkerIndexesToSort[e]=e}else if(e.data.sortSetupComplete){console.log("Sorting web worker ready."),this.splatMesh.updateIndexes(this.sortWorkerSortedIndexes,n);const e=this.splatMesh.getSplatDataTextures(),s=e.covariances.size,o=e.centerColors.size;console.log("Covariances texture size: "+s.x+" x "+s.y),console.log("Centers/colors texture size: "+o.x+" x "+o.y),this.sortWorker=r,t()}}}))}gatherSceneNodes=function(){const e=[],t=new r.Vector3,n=new r.Vector3,s=new r.Vector3,o=new r.Matrix4,i=new r.Vector3,a=new r.Vector3(0,0,-1),c=new r.Vector3,l=e=>c.copy(e.max).sub(e.min).length();return function(c){this.getRenderDimensions(i);const h=i.y/2/Math.tan(this.camera.fov/2*r.MathUtils.DEG2RAD),d=Math.atan(i.x/2/h),p=Math.atan(i.y/2/h),u=Math.cos(d),m=Math.cos(p);o.copy(this.camera.matrixWorld).invert(),o.multiply(this.splatMesh.matrixWorld);const f=this.splatMesh.getSplatTree();let y=0,g=0;const C=f.nodesWithIndexes.length;for(let r=0;r<C;r++){const i=f.nodesWithIndexes[r];s.copy(i.center).applyMatrix4(o);const h=s.length();s.normalize(),t.copy(s).setX(0).normalize(),n.copy(s).setY(0).normalize();const d=a.dot(n),p=a.dot(t),C=l(i);!c&&(d<u-.6||p<m-.6||h>125)&&h>C||(g+=i.data.indexes.length,e[y]=i,i.data.distanceToNode=h,y++)}e.length=y,e.sort(((e,t)=>e.data.distanceToNode<t.data.distanceToNode?-1:1)),this.splatRenderCount=g;let A=g*N.BytesPerInt;for(let t=0;t<y;t++){const n=e[t],r=n.data.indexes.length,s=r*N.BytesPerInt;new Uint32Array(this.sortWorkerIndexesToSort.buffer,A-s,r).set(n.data.indexes),A-=s}}}();start(){if(!this.selfDrivenMode)throw new Error("Cannot start viewer unless it is in self driven mode.");requestAnimationFrame(this.selfDrivenUpdateFunc),this.selfDrivenModeRunning=!0}stop(){this.selfDrivenMode&&this.selfDrivenModeRunning&&(cancelAnimationFrame(),this.selfDrivenModeRunning=!1)}selfDrivenUpdate(){this.selfDrivenMode&&requestAnimationFrame(this.selfDrivenUpdateFunc),this.update(),this.render()}setRenderer(e){this.renderer=e,this.splatMesh&&this.splatMesh.setRenderer(this.renderer)}setCamera(e){this.camera=e,this.controls&&(this.controls.object=e)}update(e,t){e&&this.setRenderer(e),t&&this.setCamera(t),this.initializeFromExternalUpdate&&this.init(),this.initialized&&this.splatRenderingInitialized&&(this.controls&&this.controls.update(),this.updateView(),this.updateForRendererSizeChanges(),this.updateSplatMeshUniforms(),this.updateMeshCursor(),this.updateFPS(),this.timingSensitiveUpdates(),this.updateInfo(),this.updateControlPlane())}render=function(){if(!this.initialized||!this.splatRenderingInitialized)return;const e=this.renderer.autoClear;this.renderer.autoClear=!1,(e=>{for(let t of e.children)if(t.visible)return!0;return!1})(this.scene)&&this.renderer.render(this.scene,this.camera),this.renderer.render(this.splatMesh,this.camera),this.sceneHelper.getFocusMarkerOpacity()>0&&this.renderer.render(this.sceneHelper.focusMarker,this.camera),this.showControlPlane&&this.renderer.render(this.sceneHelper.controlPlane,this.camera),this.renderer.autoClear=e};updateFPS=function(){let e=a(),t=0;return function(){const n=a();n-e>=1?(this.currentFPS=t,t=0,e=n):t++}}();updateForRendererSizeChanges=function(){const e=new r.Vector2,t=new r.Vector2;return function(){this.renderer.getSize(t),t.x===e.x&&t.y===e.y||(this.usingExternalCamera||(this.camera.aspect=t.x/t.y,this.camera.updateProjectionMatrix()),e.copy(t))}}();timingSensitiveUpdates=function(){let e;return function(){const t=a();e||(e=t);const n=t-e;this.updateCameraTransition(t),this.updateFocusMarker(n),e=t}}();updateCameraTransition=function(){let e=new r.Vector3,t=new r.Vector3,n=new r.Vector3;return function(r){if(this.transitioningCameraTarget){t.copy(this.previousCameraTarget).sub(this.camera.position).normalize(),n.copy(this.nextCameraTarget).sub(this.camera.position).normalize();const s=Math.acos(t.dot(n)),o=(s/(Math.PI/3)*.65+.3)/s*(r-this.transitioningCameraTargetStartTime);e.copy(this.previousCameraTarget).lerp(this.nextCameraTarget,o),this.camera.lookAt(e),this.controls.target.copy(e),o>=1&&(this.transitioningCameraTarget=!1)}}}();updateFocusMarker=function(){const e=new r.Vector2;let t=!1;return function(n){this.getRenderDimensions(e);if(this.transitioningCameraTarget){this.sceneHelper.setFocusMarkerVisibility(!0);const r=Math.max(this.sceneHelper.getFocusMarkerOpacity(),0);let s=Math.min(r+10*n,1);this.sceneHelper.setFocusMarkerOpacity(s),this.sceneHelper.updateFocusMarker(this.nextCameraTarget,this.camera,e),t=!0}else{let r;if(r=t?1:Math.min(this.sceneHelper.getFocusMarkerOpacity(),1),r>0){this.sceneHelper.updateFocusMarker(this.nextCameraTarget,this.camera,e);let t=Math.max(r-2.5*n,0);this.sceneHelper.setFocusMarkerOpacity(t),0===t&&this.sceneHelper.setFocusMarkerVisibility(!1)}t=!1}}}();updateMeshCursor=function(){const e=[],t=new r.Vector2;return function(){this.showMeshCursor?(this.getRenderDimensions(t),e.length=0,this.raycaster.setFromCameraAndScreenPosition(this.camera,this.mousePosition,t),this.raycaster.intersectSplatMesh(this.splatMesh,e),e.length>0?(this.sceneHelper.setMeshCursorVisibility(!0),this.sceneHelper.positionAndOrientMeshCursor(e[0].origin,this.camera)):this.sceneHelper.setMeshCursorVisibility(!1)):this.sceneHelper.setMeshCursorVisibility(!1)}}();updateInfo=function(){const e=new r.Vector2;return function(){if(!this.showInfo)return;const t=this.splatMesh.getSplatCount();this.getRenderDimensions(e);const n=this.camera.position,r=`[${n.x.toFixed(5)}, ${n.y.toFixed(5)}, ${n.z.toFixed(5)}]`;this.infoPanelCells.cameraPosition.innerHTML=r;const s=this.controls.target,o=`[${s.x.toFixed(5)}, ${s.y.toFixed(5)}, ${s.z.toFixed(5)}]`;this.infoPanelCells.cameraLookAt.innerHTML=o;const i=this.camera.up,a=`[${i.x.toFixed(5)}, ${i.y.toFixed(5)}, ${i.z.toFixed(5)}]`;if(this.infoPanelCells.cameraUp.innerHTML=a,this.showMeshCursor){const e=this.sceneHelper.meshCursor.position,t=`[${e.x.toFixed(5)}, ${e.y.toFixed(5)}, ${e.z.toFixed(5)}]`;this.infoPanelCells.cursorPosition.innerHTML=t}else this.infoPanelCells.cursorPosition.innerHTML="N/A";this.infoPanelCells.fps.innerHTML=this.currentFPS,this.infoPanelCells.renderWindow.innerHTML=`${e.x} x ${e.y}`;const c=this.splatRenderCount/t*100;this.infoPanelCells.renderSplatCount.innerHTML=`${this.splatRenderCount} splats out of ${t} (${c.toFixed(2)}%)`,this.infoPanelCells.sortTime.innerHTML=`${this.lastSortTime.toFixed(3)} ms`}}();updateControlPlane(){this.showControlPlane?(this.sceneHelper.setControlPlaneVisibility(!0),this.sceneHelper.positionAndOrientControlPlane(this.controls.target,this.camera.up)):this.sceneHelper.setControlPlaneVisibility(!1)}updateView=function(){const e=new r.Matrix4,t=[],n=new r.Vector3(0,0,-1),s=new r.Vector3(0,0,-1),o=new r.Vector3,i=new r.Vector3,a=[],c=[{angleThreshold:.55,sortFractions:[.125,.33333,.75]},{angleThreshold:.65,sortFractions:[.33333,.66667]},{angleThreshold:.8,sortFractions:[.5]}];return function(r=!1,l=!1){let h=0,d=0;s.set(0,0,-1).applyQuaternion(this.camera.quaternion);let p=!1,u=!1;if(h=s.dot(n),d=i.copy(this.camera.position).sub(o).length(),(r||0!==a.length||(h<=.95&&(p=!0),d>=1&&(u=!0),p||u))&&(e.copy(this.camera.matrixWorld).invert(),e.premultiply(this.camera.projectionMatrix),e.multiply(this.splatMesh.matrixWorld),t[0]=this.camera.position.x,t[1]=this.camera.position.y,t[2]=this.camera.position.z,!this.sortRunning)){let r;if(this.sortRunning=!0,this.gatherSceneNodes(l),this.gpuAcceleratedSort&&(a.length<=1||a.length%2==0)&&this.splatMesh.computeDistancesOnGPU(e,this.sortWorkerPrecomputedDistances),0===a.length){for(let e of c)if(h<e.angleThreshold){for(let t of e.sortFractions)a.push(Math.floor(this.splatRenderCount*t));break}a.push(this.splatRenderCount)}r=Math.min(a.shift(),this.splatRenderCount),this.sortWorker.postMessage({sort:{viewProj:this.splatMesh.getIntegerMatrixArray(e),cameraPosition:t,splatRenderCount:this.splatRenderCount,splatSortCount:r,usePrecomputedDistances:this.gpuAcceleratedSort}}),0===a.length&&(o.copy(this.camera.position),n.copy(s))}}}();getSplatMesh(){return this.splatMesh}isMobile(){return navigator.userAgent.includes("Mobi")}}class G extends r.Group{constructor(e={}){super(),e.selfDrivenMode=!1,e.useBuiltInControls=!1,e.rootElement=null,e.ignoreDevicePixelRatio=!1,e.initializeFromExternalUpdate=!0,e.camera=void 0,e.renderer=void 0,this.viewer=new W(e),this.callbackMesh=this.createCallbackMesh(),this.add(this.callbackMesh),this.callbackMesh.onBeforeRender=this.onBeforeRender.bind(this)}addSceneFromFile(e,t={}){return!1!==t.showLoadingSpinner&&(t.showLoadingSpinner=!0),this.viewer.loadFile(e,t).then((()=>{this.add(this.viewer.splatMesh)}))}addScenesFromFiles(e,t){return!1!==t&&(t=!0),this.viewer.loadFiles(e,t).then((()=>{this.add(this.viewer.splatMesh)}))}onBeforeRender(e,t,n){this.viewer.update(e,n)}createCallbackMesh(){const e=new r.SphereGeometry(1,8,8),t=new r.MeshBasicMaterial;t.colorWrite=!1,t.depthWrite=!1;const n=new r.Mesh(e,t);return n.frustumCulled=!1,n}}e.OrbitControls=T,e.PlyLoader=A,e.PlyParser=C,e.RenderableViewer=G,e.SplatBuffer=y,e.SplatCompressor=g,e.SplatLoader=v,e.Viewer=W}));
//# sourceMappingURL=gaussian-splats-3d.umd.min.cjs.map
